/**
 * @author Ozgur Demirtas
 * 
 * Created on 8/03/2005
 * 
 * initializes the tool's authoring mode  
 */

/**
 * Tool path The URL path for the tool should be <lamsroot>/tool/$TOOL_SIG.
 * 
 * CONTENT_LOCKED refers to content being in use or not: Any students answered that content?
 * For future CONTENT_LOCKED ->CONTENT_IN_USE 
 * 
 * QaStarterAction loads the default content and initializes the presentation Map
 * Requests can come either from authoring envuironment or from the monitoring environment for Edit Activity screen
 * 
 * Check QaUtils.createAuthoringUser again User Management Service is ready
 * 
 * */

/**
 *
 * Tool Content:
 *
 * While tool's manage their own content, the LAMS core and the tools work together to create and use the content. 
 * The tool content id (toolContentId) is the key by which the tool and the LAMS core discuss data - 
 * it is generated by the LAMS core and supplied to the tool whenever content needs to be stored. 
 * The LAMS core will refer to the tool content id whenever the content needs to be used. 
 * Tool content will be covered in more detail in following sections.
 *
 * Each tool will have one piece of content that is the default content. 
 * The tool content id for this content is created as part of the installation process. 
 * Whenever a tool is asked for some tool content that does not exist, it should supply the default tool content. 
 * This will allow the system to render the normal screen, albeit with useless information, rather than crashing. 
*/

/**
*
* Authoring URL: 
*
* The tool must supply an authoring module, which will be called to create new content or edit existing content. It will be called by an authoring URL using the following format: ?????
* The initial data displayed on the authoring screen for a new tool content id may be the default tool content.
*
* Authoring UI data consists of general Activity data fields and the Tool specific data fields.
* The authoring interface will have three tabs. The mandatory (and suggested) fields are given. Each tool will have its own fields which it will add on any of the three tabs, as appropriate to the tabs' function.
*
* Basic: Displays the basic set of fields that are needed for the tool, and it could be expected that a new LAMS user would use. Mandatory fields: Title, Instructions.
* Advanced: Displays the extra fields that would be used by experienced LAMS users. Optional fields: Lock On Finish, Make Responses Anonymous
* Instructions: Displays the "instructions" fields for teachers. Mandatory fields: Online instructions, Offline instructions, Document upload.
* The "Define Later" and "Run Offline" options are set on the Flash authoring part, and not on the tool's authoring screens.
*
* Preview The tool must be able to show the specified content as if it was running in a lesson. It will be the learner url with tool access mode set to ToolAccessMode.AUTHOR.
* Export The tool must be able to export its tool content for part of the overall learning design export.
*
* The format of the serialization for export is XML. Tool will define extra namespace inside the <Content> element to add a new data element (type). Inside the data element, it can further define more structures and types as it seems fit.
* The data elements must be "version" aware. The data elements must be "type" aware if they are to be shared between Tools.
*
* LAMS Xpress (Ernie, could you put something in here. You explain it better than I do!)
* Data Exchange At present, there is no data exchange format between tools. Therefore if a tool needs to work with another tool, they will need to be combined in a new tool. We plan to have a data exchange method in a future version of LAMS.
*
*/

package org.lamsfoundation.lams.tool.qa.web;
import java.io.IOException;
import java.util.Iterator;
import java.util.Map;
import java.util.TreeMap;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.log4j.Logger;
import org.apache.struts.Globals;
import org.apache.struts.action.Action;
import org.apache.struts.action.ActionForm;
import org.apache.struts.action.ActionForward;
import org.apache.struts.action.ActionMapping;
import org.apache.struts.action.ActionMessage;
import org.apache.struts.action.ActionMessages;
import org.lamsfoundation.lams.tool.qa.QaAppConstants;
import org.lamsfoundation.lams.tool.qa.QaApplicationException;
import org.lamsfoundation.lams.tool.qa.QaComparator;
import org.lamsfoundation.lams.tool.qa.QaContent;
import org.lamsfoundation.lams.tool.qa.QaQueContent;
import org.lamsfoundation.lams.tool.qa.QaUtils;
import org.lamsfoundation.lams.tool.qa.service.IQaService;
import org.lamsfoundation.lams.tool.qa.service.QaServiceProxy;
import org.lamsfoundation.lams.usermanagement.User;


public class QaStarterAction extends Action implements QaAppConstants {
	static Logger logger = Logger.getLogger(QaStarterAction.class.getName());
	
	/**
	 * A Map  data structure is used to present the UI.
	 * It is fetched by subsequent Action classes to manipulate its content and gets parsed in the presentation layer for display.
	 */
	protected Map mapQuestionContent= new TreeMap(new QaComparator());
	
	public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) 
  								throws IOException, ServletException, QaApplicationException {
		
		QaAuthoringForm qaAuthoringForm = (QaAuthoringForm) form;
		qaAuthoringForm.resetRadioBoxes();
		
		request.getSession().setAttribute(IS_DEFINE_LATER,"false");
		request.getSession().setAttribute(DISABLE_TOOL,"");

		/**
		 * retrive the service
		 */
		IQaService qaService = QaUtils.getToolService(request);
		logger.debug("retrieving qaService from session: " + qaService);
		if (qaService == null)
		{
			qaService = QaServiceProxy.getQaService(getServlet().getServletContext());
		    logger.debug("retrieving qaService from proxy: " + qaService);
		    request.getSession().setAttribute(TOOL_SERVICE, qaService);		
		}
		
		QaUtils.configureContentRepository(request);
		
		/**
		 * retrieve the default content id based on tool signature
		 */
		long contentId=0;
		try
		{
			logger.debug("attempt retrieving tool with signatute : " + MY_SIGNATURE);
			contentId=qaService.getToolDefaultContentIdBySignature(MY_SIGNATURE);
			logger.debug("retrieved tool default contentId: " + contentId);
			if (contentId == 0)
			{
				logger.debug("default content id has not been setup");
				persistError(request,"error.defaultContent.notSetup");
		    	request.setAttribute(USER_EXCEPTION_DEFAULTCONTENT_NOTSETUP, new Boolean(true));
				return (mapping.findForward(LOAD_QUESTIONS));	
			}
		}
		catch(Exception e)
		{
			logger.debug("error getting the default content id: " + e.getMessage());
			persistError(request,"error.defaultContent.notSetup");
	    	request.setAttribute(USER_EXCEPTION_DEFAULTCONTENT_NOTSETUP, new Boolean(true));
			return (mapping.findForward(LOAD_QUESTIONS));
		}

		/**
		 * retrieve the default question content id based on default content id determined above
		 */
		try
		{
			logger.debug("retrieve the default question content based on default contentId: " + contentId);
			QaQueContent qaQueContent=qaService.getToolDefaultQuestionContent(contentId);
			logger.debug("using QaQueContent: " + qaQueContent);
			if (qaQueContent == null)
			{
				logger.debug("Exception occured: No default question content");
	    		request.setAttribute(USER_EXCEPTION_DEFAULTQUESTIONCONTENT_NOT_AVAILABLE, new Boolean(true));
				persistError(request,"error.defaultQuestionContent.notAvailable");
				return (mapping.findForward(LOAD_QUESTIONS));
			}
			/**
        	 * display a single sample question
        	 */
    		request.getSession().setAttribute(DEFAULT_QUESTION_CONTENT, qaQueContent.getQuestion());
		}
		catch(Exception e)
		{
			logger.debug("Exception occured: No default question content");
    		request.setAttribute(USER_EXCEPTION_DEFAULTQUESTIONCONTENT_NOT_AVAILABLE, new Boolean(true));
			persistError(request,"error.defaultQuestionContent.notAvailable");
			return (mapping.findForward(LOAD_QUESTIONS));
		}
		
		/**
	     * mark the http session as an authoring activity 
	     */
	    request.getSession().setAttribute(TARGET_MODE,TARGET_MODE_AUTHORING);
	    
	    /**
	     * define tab controllers for jsp
	     */
	    request.getSession().setAttribute(CHOICE_TYPE_BASIC,CHOICE_TYPE_BASIC);
	    request.getSession().setAttribute(CHOICE_TYPE_ADVANCED,CHOICE_TYPE_ADVANCED);
	    request.getSession().setAttribute(CHOICE_TYPE_INSTRUCTIONS,CHOICE_TYPE_INSTRUCTIONS);
	
	    request.getSession().setAttribute(EDITACTIVITY_EDITMODE, new Boolean(false));
	    request.setAttribute(FORM_INDEX, "0");
		
	    /**
	     * obtain and setup the current user's data 
	     */
	    String userId="";
	    User toolUser=(User)request.getSession().getAttribute(TOOL_USER);
	    if (toolUser != null)
	    	userId=toolUser.getUserId().toString();
		else
		{
			userId=request.getParameter(USER_ID);
		    try
			{
		    	/* Check QaUtils.createAuthoringUser again User Management Service is ready */
		    	User user=QaUtils.createSimpleUser(new Integer(userId)); 
		    	request.getSession().setAttribute(TOOL_USER, user);
			}
		    catch(NumberFormatException e)
			{
		    	persistError(request,"error.userId.notNumeric");
				request.setAttribute(USER_EXCEPTION_USERID_NOTNUMERIC, new Boolean(true));
				return (mapping.findForward(LOAD_QUESTIONS));
			}
		}
	    
	    if ((userId == null) || (userId.length()==0))
		{
	    	logger.debug("error: The tool expects userId");
	    	persistError(request,"error.authoringUser.notAvailable");
	    	request.setAttribute(USER_EXCEPTION_USERID_NOTAVAILABLE, new Boolean(true));
			return (mapping.findForward(LOAD_QUESTIONS));
		}
	    
	    
	    /**
	     * find out whether the request is coming from monitoring module for EditActivity tab or from authoring environment url
	     */
	    String strToolContentId="";
	    Boolean isMonitoringEditActivityVisited=(Boolean)request.getSession().getAttribute(MONITORING_EDITACTIVITY_VISITED);
	    logger.debug("isMonitoringEditActivityVisited: " + isMonitoringEditActivityVisited);
	    
	    Long monitoredContentId=(Long)request.getSession().getAttribute(MONITORED_CONTENT_ID);
	    logger.debug("MONITORED_CONTENT_ID: " + monitoredContentId);
	    
	    request.getSession().setAttribute(RENDER_MONITORING_EDITACTIVITY,new Boolean(false));
	    
		Boolean startMonitoringSummaryRequest=(Boolean)request.getAttribute(START_MONITORING_SUMMARY_REQUEST);
		if ((startMonitoringSummaryRequest != null) && (startMonitoringSummaryRequest.booleanValue()))
		{
			logger.debug("will render Monitoring Edit Activity screen");
		    if  ((isMonitoringEditActivityVisited != null) && (isMonitoringEditActivityVisited.booleanValue()))
		    {
		    	if (monitoredContentId != null)
		    	{
		    		/**
		    		 * request is from Edit Activity tab in monitoring
		    		 */
		    		strToolContentId=monitoredContentId.toString();
		    		logger.debug("request is from Edit Activity tab in monitoring: " + monitoredContentId);
		    		logger.debug("using MONITORED_CONTENT_ID: " + monitoredContentId);
		    		request.getSession().setAttribute(RENDER_MONITORING_EDITACTIVITY,new Boolean(true));
		    	}
		    }
		}
	    else
	    {
	    	logger.debug("will render authoring screen");
	    	/**
    		 * request is from authoring environment
    		 */
	    	request.setAttribute(START_MONITORING_SUMMARY_REQUEST, new Boolean(false));
	    	logger.debug("request is from authoring environment: ");
	    	strToolContentId=request.getParameter(TOOL_CONTENT_ID);
	    }
	    logger.debug("usable strToolContentId: " + strToolContentId);

	    /**
	     * Process incoming tool content id
	     * Either exists or not exists in the db yet, a toolContentId must be passed to the tool from the container 
	     */
	    long toolContentId=0;
    	try
		{
	    	toolContentId=new Long(strToolContentId).longValue();
	    	logger.debug("passed TOOL_CONTENT_ID : " + toolContentId);
	    	request.getSession().setAttribute(TOOL_CONTENT_ID,strToolContentId);
    	}
    	catch(NumberFormatException e)
		{
	    	persistError(request,"error.numberFormatException");
			request.setAttribute(USER_EXCEPTION_NUMBERFORMAT, new Boolean(true));
			logger.debug("forwarding to: " + LOAD_QUESTIONS);
			return (mapping.findForward(LOAD_QUESTIONS));
		}


		/**
		 * find out if the passed tool content id exists in the db 
		 * present user either a first timer screen with default content data or fetch the existing content.
		 * 
		 * if the toolcontentid does not exist in the db, create the default Map,
		 * there is no need to check if the content is locked in this case.
		 * It is always unlocked since it is the default content.
		*/
		if (!existsContent(toolContentId, request)) 
		{
		    /**
		     * get default content from db, user never created any content before
		     */
			contentId=qaService.getToolDefaultContentIdBySignature(MY_SIGNATURE);
		    logger.debug("getting default content with id:" + contentId);
		    
		    QaContent defaultQaContent = qaService.retrieveQa(contentId);
			logger.debug("defaultQaContent: " + defaultQaContent);
			
			/**
			 * this is a new content creation, the content must always be unlocked
			 * CONTENT_LOCKED means CONTENT_IN_USE  
			 */
			request.getSession().setAttribute(CONTENT_LOCKED, new Boolean(false));
		    logger.debug("CONTENT_LOCKED: " + request.getSession().getAttribute(CONTENT_LOCKED));
			
			if (defaultQaContent == null)
			{
				logger.debug("Exception occured: No default content");
				request.setAttribute(USER_EXCEPTION_DEFAULTCONTENT_NOT_AVAILABLE, new Boolean(true));
				persistError(request,"error.defaultContent.notAvailable");
				return (mapping.findForward(LOAD_QUESTIONS));
			}
				
			QaUtils.setDefaultSessionAttributes(request, defaultQaContent, qaAuthoringForm);
			qaAuthoringForm.setUsernameVisible(OFF);
			logger.debug("UsernameVisible: " + qaAuthoringForm.getUsernameVisible());
			qaAuthoringForm.setQuestionsSequenced(OFF);
			qaAuthoringForm.setSynchInMonitor(OFF);
			
			mapQuestionContent.clear();
	    	/**
	    	 * place the default question as the first entry in the Map
	    	 */
			mapQuestionContent.put(INITIAL_QUESTION_COUNT,request.getSession().getAttribute(DEFAULT_QUESTION_CONTENT));
			logger.debug("Map initialized with default contentid to: " + mapQuestionContent);
		}
		else
		{
			/**
			 * fetch the existing content from db, user will be presented with her previously created content data
			 * Note that the content might have been LOCKED(content in use) if one or more learner has started activities with this content
			 */
		    logger.debug("getting existing content with id:" + toolContentId);
		    QaContent defaultQaContent = qaService.retrieveQa(toolContentId);
			logger.debug("defaultQaContent: " + defaultQaContent);
			
			boolean studentActivity=qaService.studentActivityOccurredGlobal(defaultQaContent);
			logger.debug("studentActivity on content: " + studentActivity);
			if (studentActivity)
			{
				logger.debug("forward to warning screen as the content is not allowed to be modified.");
				ActionMessages errors= new ActionMessages();
				errors.add(Globals.ERROR_KEY, new ActionMessage("error.content.inUse"));
				saveErrors(request,errors);
				request.getSession().setAttribute(CONTENT_LOCKED, new Boolean(true));
				logger.debug("forwarding to:" + LOAD);
				return (mapping.findForward(LOAD));
			}
			
		    request.getSession().setAttribute(CONTENT_LOCKED, new Boolean(isContentLocked(defaultQaContent)));
		    logger.debug("CONTENT_LOCKED: " + request.getSession().getAttribute(CONTENT_LOCKED));
			
			QaUtils.setDefaultSessionAttributes(request, defaultQaContent, qaAuthoringForm);
			
			/**
			 * determine the status of radio boxes
			 */
			logger.debug("IS_USERNAME_VISIBLE: " + defaultQaContent.isUsernameVisible());
		    logger.debug("set UsernameVisible to : " + defaultQaContent.isUsernameVisible());
		    if (defaultQaContent.isUsernameVisible())
		    	qaAuthoringForm.setUsernameVisible(ON);
		    else
		    	qaAuthoringForm.setUsernameVisible(OFF);
		    logger.debug("UsernameVisible: " + qaAuthoringForm.getUsernameVisible());
		    if (defaultQaContent.isSynchInMonitor())
		    	qaAuthoringForm.setSynchInMonitor(ON);
		    else
		    	qaAuthoringForm.setSynchInMonitor(OFF);
		    	
		    if (defaultQaContent.isQuestionsSequenced())
		    	qaAuthoringForm.setQuestionsSequenced(ON);
		    else
		    	qaAuthoringForm.setQuestionsSequenced(OFF);
		    
		    request.getSession().setAttribute(IS_USERNAME_VISIBLE_MONITORING, 	new Boolean(defaultQaContent.isUsernameVisible()));
		    request.getSession().setAttribute(IS_SYNCH_INMONITOR_MONITORING, 	new Boolean(defaultQaContent.isSynchInMonitor()));
		    request.getSession().setAttribute(IS_QUESTIONS_SEQUENCED_MONITORING,new Boolean(defaultQaContent.isQuestionsSequenced()));
		    request.getSession().setAttribute(IS_DEFINE_LATER, 					new Boolean(defaultQaContent.isDefineLater()));
		    request.getSession().setAttribute(REPORT_TITLE, 					defaultQaContent.getReportTitle());
		    request.getSession().setAttribute(MONITORING_REPORT_TITLE, 			defaultQaContent.getMonitoringReportTitle());
		    request.getSession().setAttribute(OFFLINE_INSTRUCTIONS, 			defaultQaContent.getOfflineInstructions());
		    request.getSession().setAttribute(ONLINE_INSTRUCTIONS, 				defaultQaContent.getOnlineInstructions());
		    request.getSession().setAttribute(RICHTEXT_OFFLINEINSTRUCTIONS,		defaultQaContent.getOfflineInstructions());
		    request.getSession().setAttribute(RICHTEXT_ONLINEINSTRUCTIONS,		defaultQaContent.getOnlineInstructions());
		    request.getSession().setAttribute(RICHTEXT_TITLE,					defaultQaContent.getTitle());
		    request.getSession().setAttribute(RICHTEXT_INSTRUCTIONS,			defaultQaContent.getInstructions());
		    logger.debug("QaStarter set all 4 rich text properties");
		    
		    request.getSession().setAttribute(END_LEARNING_MESSSAGE, 			defaultQaContent.getEndLearningMessage());
		    request.getSession().setAttribute(CREATION_DATE, 					defaultQaContent.getCreationDate());
		    
		    logger.debug("IS_QUESTIONS_SEQUENCED_MONITORING: " + request.getSession().getAttribute(IS_QUESTIONS_SEQUENCED_MONITORING));
		    logger.debug("IS_DEFINE_LATER: " + request.getSession().getAttribute(IS_DEFINE_LATER));
		    
			/**
			 * get the existing question content
			 */
			logger.debug("setting existing content data from the db");
			mapQuestionContent.clear();
			Iterator queIterator=defaultQaContent.getQaQueContents().iterator();
			Long mapIndex=new Long(1);
			logger.debug("mapQuestionContent: " + mapQuestionContent);
	    	while (queIterator.hasNext())
	    	{
	    		QaQueContent qaQueContent=(QaQueContent) queIterator.next();
	    		if (qaQueContent != null)
	    		{
	    			logger.debug("question: " + qaQueContent.getQuestion());
		    		mapQuestionContent.put(mapIndex.toString(),qaQueContent.getQuestion());
		    		/**
		    		 * make the first entry the default(first) one for jsp
		    		 */
		    		if (mapIndex.longValue() == 1)
		    			request.getSession().setAttribute(DEFAULT_QUESTION_CONTENT, qaQueContent.getQuestion());
		    		mapIndex=new Long(mapIndex.longValue()+1);
	    		}
	    	}
	    	logger.debug("Map initialized with existing contentid to: " + mapQuestionContent);
		}
		
    	request.getSession().setAttribute(MAP_QUESTION_CONTENT, mapQuestionContent);
		logger.debug("starter initialized the Comparable Map: " + request.getSession().getAttribute("mapQuestionContent") );
	/**
	 * load questions page
	 */
	
	logger.debug("START_MONITORING_SUMMARY_REQUEST: " + request.getAttribute(START_MONITORING_SUMMARY_REQUEST));
	logger.debug("RENDER_MONITORING_EDITACTIVITY: " + request.getAttribute(RENDER_MONITORING_EDITACTIVITY));
	qaAuthoringForm.resetUserAction();
	return (mapping.findForward(LOAD_QUESTIONS));
  } 
	

	/**
	 * existsContent(long toolContentId)
	 * @param long toolContentId
	 * @return boolean
	 * determine whether a specific toolContentId exists in the db
	 */
	protected boolean existsContent(long toolContentId, HttpServletRequest request)
	{
		/**
		 * retrive the service
		 */
		IQaService qaService =QaUtils.getToolService(request);
		QaContent qaContent=qaService.loadQa(toolContentId);
	    if (qaContent == null) 
	    	return false;
	    
		return true;	
	}
	
	/**
	 * find out if the content is locked or not. If it is a locked content, the author can not modify it.
	 * The idea of content being locked is, once any one learner starts using a particular content
	 * that content should become unmodifiable. 
	 * @param qaContent
	 * @return
	 */
	protected boolean isContentLocked(QaContent qaContent)
	{
		logger.debug("is content locked: " + qaContent.isContentLocked());
		return qaContent.isContentLocked();
	}
	
	
	public ActionForward startMonitoringSummary(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response)
															throws IOException, ServletException, QaApplicationException 
	{
		request.setAttribute(START_MONITORING_SUMMARY_REQUEST, new Boolean(true));
		return execute(mapping, form, request, response);
	}
	
	
	/**
     * persists error messages to request scope
     * @param request
     * @param message
     */
	public void persistError(HttpServletRequest request, String message)
	{
		ActionMessages errors= new ActionMessages();
		errors.add(Globals.ERROR_KEY, new ActionMessage(message));
		logger.debug("add " + message +"  to ActionMessages:");
		saveErrors(request,errors);	    	    
	}
}  
