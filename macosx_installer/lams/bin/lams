#! /bin/bash

#chkconfig: 2345 91 20
# Comments to support LSB init script conventions
### BEGIN INIT INFO
# Provides: lams
# Required-Start: $local_fs $network $remote_fs
# Required-Stop: $local_fs $network $remote_fs
# Default-Start:  3 4 5
# Default-Stop: 0 1 6
# Short-Description: start and stop LAMS
# Description: LAMS Server 
### END INIT INFO


source /usr/local/lams/bin/lams.conf

# Application
APP_NAME="run-lams.sh"
APP_LONG_NAME="LAMS Server $LAMS_VERSION"
APP_PID_FILE="$LAMS_HOME/lams.pid"

# Wrapper

#RUN_AS_USER=

# Do not modify anything beyond this point
#-----------------------------------------------------------------------------

# Get the fully qualified path to the script
case $0 in
    /*)
        SCRIPT="$0"
        ;;
    *)
        PWD=`pwd`
        SCRIPT="$PWD/$0"
        ;;
esac

# Change spaces to ":" so the tokens can be parsed.
SCRIPT=`echo $SCRIPT | sed -e 's; ;:;g'`
# Get the real path to this script, resolving any symbolic links
TOKENS=`echo $SCRIPT | sed -e 's;/; ;g'`
REALPATH=
for C in $TOKENS; do
    REALPATH="$REALPATH/$C"
    while [ -h "$REALPATH" ] ; do
        LS="`ls -ld "$REALPATH"`"
        LINK="`expr "$LS" : '.*-> \(.*\)$'`"
        if expr "$LINK" : '/.*' > /dev/null; then
            REALPATH="$LINK"
        else
            REALPATH="`dirname "$REALPATH"`""/$LINK"
        fi
    done
done
# Change ":" chars back to spaces.
REALPATH=`echo $REALPATH | sed -e 's;:; ;g'`

# Change the current directory to the location of the script
cd "`dirname "$REALPATH"`"

# Process ID
pid=""

# Resolve the location of the 'ps' command
PSEXE="/usr/bin/ps"
if [ ! -x $PSEXE ]
then
    PSEXE="/bin/ps"
    if [ ! -x $PSEXE ]
    then
        echo "Unable to locate 'ps'."
        echo "Please report this message along with the location of the command on your system."
        exit 1
    fi
fi

# Check the configured user
if [ "X$RUN_AS_USER" != "X" ]
then
    # Resolve the location of the 'id' command
    IDEXE="/usr/xpg4/bin/id"
    if [ ! -x $IDEXE ]
    then
        IDEXE="/usr/bin/id"
        if [ ! -x $IDEXE ]
        then
            echo "Unable to locate 'id'."
            echo "Please report this message along with the location of the command on your system."
            exit 1
        fi
    fi

    if [ "`$IDEXE -u -n`" = "$RUN_AS_USER" ]
    then
        # Already running as the configured user.  Avoid password prompts by not calling su.
        RUN_AS_USER=""
    fi
fi

getpid() {
      pid=`$PSEXE -axwwwo pid,command | grep $APP_NAME | grep -v grep | awk '{print $1}' | tail -1`
}

testpid() {
      pid=`$PSEXE -axwwwo pid,command | grep $APP_NAME | grep -v grep | awk '{print $1}' | tail -1`
}

startit() {
    echo "Starting $APP_LONG_NAME..."
    getpid
    if [ "X$pid" = "X" ]
    then
            if [ "X$RUN_AS_USER" = "X" ]
            then
		cd $JBOSS_HOME/bin/; ./$APP_NAME &
		getpid
		echo $pid > $APP_PID_FILE
		# starts wildfire
		cd $LAMS_HOME/wildfire/bin; ./wildfire start &
            else
                su -m $RUN_AS_USER -c "cd $JBOSS_HOME/bin/; ./$APP_NAME &"
            fi
		
    else
        echo "$APP_LONG_NAME is already running."
        exit 1
    fi
}
 
stopit() {
    echo "Stopping $APP_LONG_NAME..."
    getpid
    echo $pid
    if [ "X$pid" = "X" ]
    then
        echo "$APP_LONG_NAME was not running."
    else
        if [ "X$IGNORE_SIGNALS" = "X" ]
        then
            # Running so try to stop it.
            kill $pid
	    rm -rf $APP_PID_FILE
            if [ $? -ne 0 ]
            then
                # An explanation for the failure should have been given
                echo "Unable to stop $APP_LONG_NAME."
                exit 1
            fi
	    # stops wildfire
	    cd $LAMS_HOME/wildfire/bin; ./wildfire stop
        fi

        # We can not predict how long it will take for the wrapper to
        #  actually stop as it depends on settings in wrapper.conf.
        #  Loop until it does.
        savepid=$pid
        CNT=0
        TOTCNT=0
        while [ "X$pid" != "X" ]
        do
            # Loop for up to 5 minutes
            if [ "$TOTCNT" -lt "300" ]
            then
                if [ "$CNT" -lt "5" ]
                then
                    CNT=`expr $CNT + 1`
                else
                    echo "Waiting for $APP_LONG_NAME to exit..."
                    CNT=0
                fi
                TOTCNT=`expr $TOTCNT + 1`

                sleep 1

                testpid
            else
                pid=
            fi
        done

        pid=$savepid
        testpid
        if [ "X$pid" != "X" ]
        then
            echo "Timed out waiting for $APP_LONG_NAME to exit."
            echo "  Attempting a forced exit..."
            kill -9 $pid
        fi

        pid=$savepid
        testpid
        if [ "X$pid" != "X" ]
        then
            echo "Failed to stop $APP_LONG_NAME."
            exit 1
        else
            echo "Stopped $APP_LONG_NAME."
        fi
    fi
}

status() {
    getpid
    if [ "X$pid" = "X" ]
    then
        echo "$APP_LONG_NAME is not running."
        exit 0
    else
        echo "$APP_LONG_NAME is running ($pid)."
        exit 0
    fi
}

dump() {
    echo "Dumping $APP_LONG_NAME..."
    getpid
    if [ "X$pid" = "X" ]
    then
        echo "$APP_LONG_NAME was not running."

    else
        kill -3 $pid

        if [ $? -ne 0 ]
        then
            echo "Failed to dump $APP_LONG_NAME."
            exit 1
        else
            echo "Dumped $APP_LONG_NAME."
        fi
    fi
}

case "$1" in

    'start')
        startit
        ;;

    'stop')
        stopit
        ;;

    'restart')
        stopit
        startit
        ;;

    'status')
        status
        ;;

    'dump')
        dump
        ;;

    *)
        echo "Usage: $0 { start | stop | restart | status | dump }"
        exit 1
        ;;
esac

exit 0
