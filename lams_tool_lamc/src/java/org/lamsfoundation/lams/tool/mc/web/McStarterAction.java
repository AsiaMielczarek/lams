/****************************************************************
 * Copyright (C) 2005 LAMS Foundation (http://lamsfoundation.org)
 * =============================================================
 * License Information: http://lamsfoundation.org/licensing/lams/2.0/
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
 * USA
 * 
 * http://www.gnu.org/licenses/gpl.txt
 * ****************************************************************
 */

/**
 * @author Ozgur Demirtas
 * 
 * Created on 8/03/2005
 * 
 */

/**
 * Tool path The URL path for the tool should be <lamsroot>/tool/$TOOL_SIG.
 * 
 * McStarterAction loads the default content and initializes the presentation Map
 * Requests can come either from authoring envuironment or from the monitoring environment for Edit Activity screen
 * 
 * Check McUtils.createAuthoringUser again User Management Service is ready
 * 
 * */

/**
 *
 * Tool Content:
 *
 * While tool's manage their own content, the LAMS core and the tools work together to create and use the content. 
 * The tool content id (toolContentID) is the key by which the tool and the LAMS core discuss data - 
 * it is generated by the LAMS core and supplied to the tool whenever content needs to be stored. 
 * The LAMS core will refer to the tool content id whenever the content needs to be used. 
 * Tool content will be covered in more detail in following sections.
 *
 * Each tool will have one piece of content that is the default content. 
 * The tool content id for this content is created as part of the installation process. 
 * Whenever a tool is asked for some tool content that does not exist, it should supply the default tool content. 
 * This will allow the system to render the normal screen, albeit with useless information, rather than crashing. 
*/

/**
*
* Authoring URL: 
*
* The tool must supply an authoring module, which will be called to create new content or edit existing content. It will be called by an authoring URL using the following format: ?????
* The initial data displayed on the authoring screen for a new tool content id may be the default tool content.
*
* Authoring UI data consists of general Activity data fields and the Tool specific data fields.
* The authoring interface will have three tabs. The mandatory (and suggested) fields are given. Each tool will have its own fields which it will add on any of the three tabs, as appropriate to the tabs' function.
*
* Basic: Displays the basic set of fields that are needed for the tool, and it could be expected that a new LAMS user would use. Mandatory fields: Title, Instructions.
* Advanced: Displays the extra fields that would be used by experienced LAMS users. Optional fields: Lock On Finish, Make Responses Anonymous
* Instructions: Displays the "instructions" fields for teachers. Mandatory fields: Online instructions, Offline instructions, Document upload.
* The "Define Later" and "Run Offline" options are set on the Flash authoring part, and not on the tool's authoring screens.
*
* Preview The tool must be able to show the specified content as if it was running in a lesson. It will be the learner url with tool access mode set to ToolAccessMode.AUTHOR.
* Export The tool must be able to export its tool content for part of the overall learning design export.
*
* The format of the serialization for export is XML. Tool will define extra namespace inside the <Content> element to add a new data element (type). Inside the data element, it can further define more structures and types as it seems fit.
* The data elements must be "version" aware. The data elements must be "type" aware if they are to be shared between Tools.
* 
* 
  <!-- ========== Action Mapping Definitions =================================== -->

   <!--Authoring Starter  -->
    <action
		path="/authoringStarter"
		type="org.lamsfoundation.lams.tool.mc.web.McStarterAction"
		name="McAuthoringForm"
		scope="request"
		unknown="false"
		validate="false"
    >

	    <forward
			name="load"
			path="/AuthoringMaincontent.jsp"
			redirect="false"
	    />
	
	    <forward
			name="loadViewOnly"
	      	path="/authoring/AuthoringTabsHolder.jsp"
	      	redirect="false"
	    />

	  	<forward
			name="loadMonitoring"
			path="/monitoring/MonitoringMaincontent.jsp"
			redirect="false"
	  	/>
	
	  	<forward
			name="refreshMonitoring"
			path="/monitoring/MonitoringMaincontent.jsp"
			redirect="false"
	  	/>
	
	</action>  

* 
*/


/* $$Id$$ */
package org.lamsfoundation.lams.tool.mc.web;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.log4j.Logger;
import org.apache.struts.Globals;
import org.apache.struts.action.Action;
import org.apache.struts.action.ActionForm;
import org.apache.struts.action.ActionForward;
import org.apache.struts.action.ActionMapping;
import org.apache.struts.action.ActionMessage;
import org.apache.struts.action.ActionMessages;
import org.lamsfoundation.lams.tool.mc.McAppConstants;
import org.lamsfoundation.lams.tool.mc.McApplicationException;
import org.lamsfoundation.lams.tool.mc.McComparator;
import org.lamsfoundation.lams.tool.mc.McGeneralAuthoringDTO;
import org.lamsfoundation.lams.tool.mc.McUtils;
import org.lamsfoundation.lams.tool.mc.pojos.McContent;
import org.lamsfoundation.lams.tool.mc.pojos.McUploadedFile;
import org.lamsfoundation.lams.tool.mc.service.IMcService;
import org.lamsfoundation.lams.tool.mc.service.McServiceProxy;
import org.lamsfoundation.lams.util.WebUtil;
import org.lamsfoundation.lams.web.util.AttributeNames;
import org.lamsfoundation.lams.web.util.SessionMap;

/**
 * 
 * @author Ozgur Demirtas
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 * 
 * A Map data structure is used to present the UI.
 */
public class McStarterAction extends Action implements McAppConstants {
	static Logger logger = Logger.getLogger(McStarterAction.class.getName());
	
	public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) 
  								throws IOException, ServletException, McApplicationException {
	
		McUtils.cleanUpSessionAbsolute(request);
	    logger.debug("init authoring mode.");
		McAuthoringForm mcAuthoringForm = (McAuthoringForm) form;
		logger.debug("mcAuthoringForm: " + mcAuthoringForm);
		
		String contentFolderID = WebUtil.readStrParam(request, AttributeNames.PARAM_CONTENT_FOLDER_ID);
		logger.debug("contentFolderID: " + contentFolderID);
		mcAuthoringForm.setContentFolderID(contentFolderID);
	
		McGeneralAuthoringDTO mcGeneralAuthoringDTO= new McGeneralAuthoringDTO();
		mcGeneralAuthoringDTO.setContentFolderID(contentFolderID);
		
		Map mapQuestionContent= new TreeMap(new McComparator());
		logger.debug("mapQuestionContent: " + mapQuestionContent);
		
		mcAuthoringForm.resetRadioBoxes();
		
		IMcService mcService =null;
		if ((getServlet() == null) || (getServlet().getServletContext() == null))
		{
		    logger.debug("obtaining mcService from the form");
		    mcService=mcAuthoringForm.getMcService();
		}
		else
		{
		    logger.debug("obtaining mcService via proxy");
		    mcService =McServiceProxy.getMcService(getServlet().getServletContext());
		}
		logger.debug("mcService: " + mcService);
		
		mcGeneralAuthoringDTO.setCurrentTab("1");
		logger.debug("setting currrent tab to 1:");
		
		
		mcGeneralAuthoringDTO.setMonitoringOriginatedDefineLater(new Boolean(false).toString());
		String servletPath=request.getServletPath();
		logger.debug("getServletPath: "+ servletPath);
		String requestedModule=null;
		if (servletPath.indexOf("authoringStarter") > 0)
		{
			logger.debug("request is for authoring module");
			mcGeneralAuthoringDTO.setActiveModule(AUTHORING);
			mcGeneralAuthoringDTO.setDefineLaterInEditMode(new Boolean(true).toString());
			mcGeneralAuthoringDTO.setShowAuthoringTabs(new Boolean(true).toString());
			mcAuthoringForm.setActiveModule(AUTHORING);
			requestedModule=AUTHORING;
		}
		else
		{
			logger.debug("request is for define later module either direcly from define later url or monitoring url");
			mcGeneralAuthoringDTO.setActiveModule(DEFINE_LATER);
			mcGeneralAuthoringDTO.setDefineLaterInEditMode(new Boolean(false).toString());
			mcGeneralAuthoringDTO.setShowAuthoringTabs(new Boolean(false).toString());
			mcAuthoringForm.setActiveModule(DEFINE_LATER);			
			requestedModule=DEFINE_LATER;
			
			if (servletPath.indexOf("monitoring") > 0)
			{
				logger.debug("request is from monitoring  url.");
				mcGeneralAuthoringDTO.setMonitoringOriginatedDefineLater(new Boolean(true).toString());
			}
		}
		logger.debug("requestedModule: " + requestedModule);
		mcGeneralAuthoringDTO.setRequestedModule(requestedModule);

	
		String sourceMcStarter = (String) request.getAttribute(SOURCE_MC_STARTER);
		logger.debug("sourceMcStarter: " + sourceMcStarter);
		
	    boolean validateSignature=readSignature(request,mapping, mcService, mcGeneralAuthoringDTO, mcAuthoringForm);
		logger.debug("validateSignature:  " + validateSignature);
		if (validateSignature == false)
		{
			logger.debug("error during validation");
		}
		
		/* mark the http session as an authoring activity */
		mcGeneralAuthoringDTO.setTargetMode(TARGET_MODE_AUTHORING);
	    
	    /*
	     * find out whether the request is coming from monitoring module for EditActivity tab or from authoring environment url
	     */
	    logger.debug("no problems getting the default content, will render authoring screen");
	    String strToolContentID="";
	    /*the authoring url must be passed a tool content id*/
	    strToolContentID=request.getParameter(AttributeNames.PARAM_TOOL_CONTENT_ID);
	    logger.debug("strToolContentID: " + strToolContentID);
	    mcGeneralAuthoringDTO.setToolContentID(strToolContentID);
	    
	    SessionMap sessionMap = new SessionMap();
	    List sequentialCheckedCa= new LinkedList();
	    sessionMap.put(ATTACHMENT_LIST_KEY, new ArrayList());
	    sessionMap.put(DELETED_ATTACHMENT_LIST_KEY, new ArrayList());
	    sessionMap.put(ACTIVITY_TITLE_KEY, "");
	    sessionMap.put(ACTIVITY_INSTRUCTIONS_KEY, "");
	    mcAuthoringForm.setHttpSessionID(sessionMap.getSessionID());
	    mcGeneralAuthoringDTO.setHttpSessionID(sessionMap.getSessionID());
	    
	    String defaultContentId=null;
	    if (strToolContentID == null)
	    {
	    	/*it is possible that the original request for authoring module is coming from monitoring url which keeps the
	    	 TOOL_CONTENT_ID in the session*/
		    logger.debug("strToolContentID is null, handle this");
	        
	    	Long toolContentID =(Long) request.getSession().getAttribute(TOOL_CONTENT_ID);
		    logger.debug("toolContentID: " + toolContentID);
		    if (toolContentID != null)
		    {
		        strToolContentID= toolContentID.toString();
			    logger.debug("cached strToolContentID from the session: " + strToolContentID);	
		    }
		    else
		    {
		    	logger.debug("we should IDEALLY not arrive here. The TOOL_CONTENT_ID is NOT available from the url or the session.");
		    	/*use default content instead of giving a warning*/
		    	defaultContentId=mcAuthoringForm.getDefaultContentIdStr();
		    	logger.debug("using MCQ defaultContentId: " + defaultContentId);
		    	strToolContentID=defaultContentId;
		    }
	    }
    	logger.debug("final strToolContentID: " + strToolContentID);
	    
	    if ((strToolContentID == null) || (strToolContentID.equals(""))) 
	    {
	    	McUtils.cleanUpSessionAbsolute(request);
	    	logger.debug("forwarding to: " + ERROR_LIST);
			//return (mapping.findForward(ERROR_LIST));
	    }

	    mcAuthoringForm.setToolContentID(strToolContentID);

		/*
		 * find out if the passed tool content id exists in the db 
		 * present user either a first timer screen with default content data or fetch the existing content.
		 * 
		 * if the toolcontentid does not exist in the db, create the default Map,
		 * there is no need to check if the content is locked in this case.
		 * It is always unlocked since it is the default content.
		*/
        
	    String defaultContentIdStr=null;
	    McContent mcContent=null;
		if (!existsContent(new Long(strToolContentID).longValue(), mcService)) 
		{
			logger.debug("getting default content");
			/*fetch default content*/
			defaultContentIdStr=mcAuthoringForm.getDefaultContentIdStr();
			logger.debug("defaultContentIdStr:" + defaultContentIdStr);
            mcContent=retrieveContent(request, mapping, mcAuthoringForm, mapQuestionContent, 
                    new Long(defaultContentIdStr).longValue(), true, mcService, mcGeneralAuthoringDTO, sessionMap);
            
            logger.debug("post retrive content :" + sessionMap); 
		}
        else
        {
        	logger.debug("getting existing content");
        	/* it is possible that the content is in use by learners.*/
        	mcContent=mcService.retrieveMc(new Long(strToolContentID));
        	
        	logger.debug("mcContent: " + mcContent);
        	if (mcService.studentActivityOccurredGlobal(mcContent))
    		{
        		McUtils.cleanUpSessionAbsolute(request);
    			logger.debug("student activity occurred on this content:" + mcContent);
    		}
        	mcContent=retrieveContent(request, mapping, mcAuthoringForm, mapQuestionContent, 
                    new Long(strToolContentID).longValue(),false, mcService, mcGeneralAuthoringDTO, sessionMap);
        	
        	logger.debug("post retrive content :" + sessionMap);        	
        }
		
		logger.debug("mcGeneralAuthoringDTO.getOnlineInstructions() :" + mcGeneralAuthoringDTO.getOnlineInstructions());
		logger.debug("mcGeneralAuthoringDTO.getOfflineInstructions():" + mcGeneralAuthoringDTO.getOfflineInstructions());
		
	    if ((mcGeneralAuthoringDTO.getOnlineInstructions() == null) || (mcGeneralAuthoringDTO.getOnlineInstructions().length() == 0))
	    {
	        mcGeneralAuthoringDTO.setOnlineInstructions(DEFAULT_ONLINE_INST);
	        mcAuthoringForm.setOnlineInstructions(DEFAULT_ONLINE_INST);
		    sessionMap.put(ONLINE_INSTRUCTIONS_KEY, DEFAULT_ONLINE_INST);
	    }
	        
	    if ((mcGeneralAuthoringDTO.getOfflineInstructions() == null) || (mcGeneralAuthoringDTO.getOfflineInstructions().length() == 0))
	    {
	        mcGeneralAuthoringDTO.setOfflineInstructions(DEFAULT_OFFLINE_INST);
	        mcAuthoringForm.setOfflineInstructions(DEFAULT_OFFLINE_INST);
	        sessionMap.put(OFFLINE_INSTRUCTIONS_KEY, DEFAULT_OFFLINE_INST);
	    }

		
	    logger.debug("final mcGeneralAuthoringDTO: " + mcGeneralAuthoringDTO);
		logger.debug("will return to jsp with: " + sourceMcStarter);
		String destination=McUtils.getDestination(sourceMcStarter, requestedModule);
		logger.debug("destination: " + destination);
		
		Map mapQuestionContentLocal=mcGeneralAuthoringDTO.getMapQuestionContent(); 
		logger.debug("mapQuestionContentLocal: " + mapQuestionContentLocal);
		
		logger.debug("mapQuestionContent: " + mapQuestionContent);
		sessionMap.put(MAP_QUESTION_CONTENT_KEY, mapQuestionContent);
		
		
		
		AuthoringUtil authoringUtil =new AuthoringUtil();
		List listAddableQuestionContentDTO=authoringUtil.buildDefaultQuestionContent(mcContent, mcService);
		logger.debug("listAddableQuestionContentDTO: " + listAddableQuestionContentDTO);
		sessionMap.put(NEW_ADDABLE_QUESTION_CONTENT_KEY, listAddableQuestionContentDTO);
		
		logger.debug("persisting sessionMap into session: " + sessionMap);
		request.getSession().setAttribute(sessionMap.getSessionID(), sessionMap);
		
		
	    Map marksMap=authoringUtil.buildMarksMap();
	    logger.debug("marksMap: " + marksMap);
	    mcGeneralAuthoringDTO.setMarksMap(marksMap);
	    mcGeneralAuthoringDTO.setMarkValue("1");
	    

	    List listQuestionContentDTOLocal=authoringUtil.buildDefaultQuestionContent(mcContent, mcService);
	    logger.debug("listQuestionContentDTOLocal: " + listQuestionContentDTOLocal);

	    Map passMarksMap=authoringUtil.buildDynamicPassMarkMap(listQuestionContentDTOLocal, true);
	    logger.debug("passMarksMap: " + passMarksMap);
	    mcGeneralAuthoringDTO.setPassMarksMap(passMarksMap);
	    
        String totalMark=AuthoringUtil.getTotalMark(listQuestionContentDTOLocal);
        logger.debug("totalMark: " + totalMark);
        mcAuthoringForm.setTotalMarks(totalMark);
        mcGeneralAuthoringDTO.setTotalMarks(totalMark);

	    
	    String passMark=" ";
	    
	    if ((mcContent.getPassMark() != null) && (mcContent.getPassMark().intValue() != 0))
	        passMark=mcContent.getPassMark().toString();
	    
	        
	    mcGeneralAuthoringDTO.setPassMarkValue (passMark);
	    
	    Map correctMap=authoringUtil.buildCorrectMap();
	    logger.debug("correctMap: " + correctMap);
	    mcGeneralAuthoringDTO.setCorrectMap(correctMap);
		
		
		logger.debug("before fwding to jsp, mcAuthoringForm : " + mcAuthoringForm);
		logger.debug("final mcGeneralAuthoringDTO: " + mcGeneralAuthoringDTO);
		request.setAttribute(MC_GENERAL_AUTHORING_DTO, mcGeneralAuthoringDTO);
		
		return (mapping.findForward(destination));
	} 
	
	
	
	/**
	 * retrives the existing content information from the db and prepares the data for presentation purposes.
	 * ActionForward retrieveExistingContent(HttpServletRequest request, ActionMapping mapping, McAuthoringForm mcAuthoringForm, Map mapQuestionContent, long toolContentID)
	 *  
	 * @param request
	 * @param mapping
	 * @param mcAuthoringForm
	 * @param mapQuestionContent
	 * @param toolContentID
	 * @return ActionForward
	 */
	protected McContent retrieveContent(HttpServletRequest request, ActionMapping mapping, McAuthoringForm mcAuthoringForm, 
	        Map mapQuestionContent, long toolContentID, boolean isDefaultContent, IMcService mcService,
	        McGeneralAuthoringDTO mcGeneralAuthoringDTO, SessionMap sessionMap)
	{
	    logger.debug("starting retrieveContent: " + mcService);
	    logger.debug("toolContentID: " + toolContentID);
		logger.debug("isDefaultContent: " + isDefaultContent);

	    logger.debug("getting content with id:" + toolContentID);
	    McContent mcContent = mcService.retrieveMc(new Long(toolContentID));
		logger.debug("McContent: " + mcContent);
		
		McUtils.populateAuthoringDTO(request, mcContent, mcGeneralAuthoringDTO);
		
		mcAuthoringForm.setSln(mcContent.isShowReport()?"1":"0");
		mcAuthoringForm.setQuestionsSequenced(mcContent.isQuestionsSequenced()?"1":"0");
		mcAuthoringForm.setRandomize(mcContent.isRandomize()?"1":"0");
		mcAuthoringForm.setShowMarks(mcContent.isShowMarks()?"1":"0");
		
		mcAuthoringForm.setRetries(mcContent.isRetries()?"1":"0");
	    mcAuthoringForm.setReflect(mcContent.isReflect()?"1":"0");
	    mcAuthoringForm.setReflectionSubject(mcContent.getReflectionSubject());		
		
		mcGeneralAuthoringDTO.setSln(mcContent.isShowReport()?"1":"0");
		mcGeneralAuthoringDTO.setQuestionsSequenced(mcContent.isQuestionsSequenced()?"1":"0");
		mcGeneralAuthoringDTO.setRandomize(mcContent.isRandomize()?"1":"0");
		mcGeneralAuthoringDTO.setRetries(mcContent.isRetries()?"1":"0");
	    mcGeneralAuthoringDTO.setReflect(mcContent.isReflect()?"1":"0");
	    mcGeneralAuthoringDTO.setReflectionSubject(mcContent.getReflectionSubject());
	
	    
	    List<McUploadedFile> attachmentList = mcService.retrieveMcUploadedFiles(mcContent); 
        mcGeneralAuthoringDTO.setAttachmentList(attachmentList);
        mcGeneralAuthoringDTO.setDeletedAttachmentList(new ArrayList());

	    sessionMap.put(ATTACHMENT_LIST_KEY, attachmentList);
	    sessionMap.put(DELETED_ATTACHMENT_LIST_KEY, new ArrayList());


	    mcGeneralAuthoringDTO.setIsDefineLater(new Boolean(mcContent.isDefineLater()).toString());
	    
		mcGeneralAuthoringDTO.setActivityTitle(mcContent.getTitle());
		mcAuthoringForm.setTitle(mcContent.getTitle());

		mcGeneralAuthoringDTO.setActivityInstructions( mcContent.getInstructions());
		mcAuthoringForm.setInstructions(mcContent.getInstructions());
		
		sessionMap.put(ACTIVITY_TITLE_KEY, mcGeneralAuthoringDTO.getActivityTitle());
	    sessionMap.put(ACTIVITY_INSTRUCTIONS_KEY, mcGeneralAuthoringDTO.getActivityInstructions());

	    
	    AuthoringUtil authoringUtil= new AuthoringUtil();
	    List listQuestionContentDTO=authoringUtil.buildDefaultQuestionContent(mcContent, mcService);
	    logger.debug("listQuestionContentDTO: " + listQuestionContentDTO);

	    request.setAttribute(TOTAL_QUESTION_COUNT, new Integer(listQuestionContentDTO.size()));
		logger.debug("listQuestionContentDTO: " + listQuestionContentDTO);
		request.setAttribute(LIST_QUESTION_CONTENT_DTO,listQuestionContentDTO);
		sessionMap.put(LIST_QUESTION_CONTENT_DTO_KEY, listQuestionContentDTO);
		
		
		if (isDefaultContent)
		{
		    logger.debug("overwriting default question.");
		    mcGeneralAuthoringDTO.setDefaultQuestionContent("Sample Question 1?");
		    
		}
		
		logger.debug("mapQuestionContent is:" + mapQuestionContent);
		mcGeneralAuthoringDTO.setMapQuestionContent(mapQuestionContent);

		
		logger.debug("mcContent.getOnlineInstructions():" + mcContent.getOnlineInstructions());
		logger.debug("mcContent.getOfflineInstructions():" + mcContent.getOfflineInstructions());
		mcGeneralAuthoringDTO.setOnlineInstructions(mcContent.getOnlineInstructions());
		mcGeneralAuthoringDTO.setOfflineInstructions(mcContent.getOfflineInstructions());
		
		mcAuthoringForm.setOnlineInstructions(mcContent.getOnlineInstructions());
		mcAuthoringForm.setOfflineInstructions(mcContent.getOfflineInstructions());
		sessionMap.put(ONLINE_INSTRUCTIONS_KEY, mcContent.getOnlineInstructions());
		sessionMap.put(OFFLINE_INSTRUCTIONS_KEY, mcContent.getOfflineInstructions());
	    
		logger.debug("ACTIVITY_TITLE_KEY set to:" +  sessionMap.get(ACTIVITY_TITLE_KEY ));
		
		mcAuthoringForm.resetUserAction();
		logger.debug("returning mcContent:" + mcContent);
		return mcContent;
	}

	
	/**
	 * each tool has a signature. MC tool's signature is stored in MY_SIGNATURE. The default tool content id and 
	 * other depending content ids are obtained in this method.
	 * if all the default content has been setup properly the method persists DEFAULT_CONTENT_ID in the session.
	 * 
	 * readSignature(HttpServletRequest request, ActionMapping mapping)
	 * @param request
	 * @param mapping
	 * @return ActionForward
	 */
	public boolean readSignature(HttpServletRequest request, ActionMapping mapping, IMcService mcService, 
	        McGeneralAuthoringDTO mcGeneralAuthoringDTO, McAuthoringForm mcAuthoringForm)
	{
		logger.debug("mcService: " + mcService);
		/*
		 * retrieve the default content id based on tool signature
		 */
		long defaultContentID=0;
		try
		{
			logger.debug("attempt retrieving tool with signatute : " + MY_SIGNATURE);
            defaultContentID=mcService.getToolDefaultContentIdBySignature(MY_SIGNATURE);
			logger.debug("retrieved tool default contentId: " + defaultContentID);
			if (defaultContentID == 0)
			{
				logger.debug("default content id has not been setup");
				return false;	
			}
		}
		catch(Exception e)
		{
			logger.debug("error getting the default content id: " + e.getMessage());
			persistError(request,"error.defaultContent.notSetup");
			return false;
		}

		
		/* retrieve uid of the content based on default content id determined above */
		long contentUID=0;
		try
		{
			logger.debug("retrieve uid of the content based on default content id determined above: " + defaultContentID);
			McContent mcContent=mcService.retrieveMc(new Long(defaultContentID));
			if (mcContent == null)
			{
				logger.debug("Exception occured: No default content");
	    		persistError(request,"error.defaultContent.notSetup");
	    		return false;
			}
			logger.debug("using mcContent: " + mcContent);
			logger.debug("using mcContent uid: " + mcContent.getUid());
			contentUID=mcContent.getUid().longValue();
			logger.debug("contentUID: " + contentUID);
		}
		catch(Exception e)
		{
			logger.debug("Exception occured: No default question content");
			persistError(request,"error.defaultContent.notSetup");
			return false;
		}

		
		logger.debug("MC tool has the default content id: " + defaultContentID);
		mcGeneralAuthoringDTO.setDefaultContentIdStr(new Long(defaultContentID).toString());
		mcAuthoringForm.setDefaultContentIdStr(new Long(defaultContentID).toString());
		
		return true;
	}
	
	
	
	/**
	 * existsContent(long toolContentID)
	 * @param long toolContentID
	 * @return boolean
	 * determine whether a specific toolContentID exists in the db
	 */
	protected boolean existsContent(long toolContentID, IMcService mcService)
	{
		McContent mcContent=mcService.retrieveMc(new Long(toolContentID));
	    if (mcContent == null) 
	    	return false;
	    
		return true;	
	}
	
	
	/**
	 * bridges define later url request to authoring functionality
	 * 
	 * executeDefineLater(ActionMapping mapping, ActionForm form, 
			HttpServletRequest request, HttpServletResponse response, IMcService mcService) 
		throws IOException, ServletException, McApplicationException
	 * 
	 * @param mapping
	 * @param form
	 * @param request
	 * @param response
	 * @param mcService
	 * @return
	 * @throws IOException
	 * @throws ServletException
	 * @throws McApplicationException
	 */
	public ActionForward executeDefineLater(ActionMapping mapping, McAuthoringForm mcAuthoringForm, 
			HttpServletRequest request, HttpServletResponse response, IMcService mcService) 
		throws IOException, ServletException, McApplicationException {
		logger.debug("calling execute..., mcService will be needed next.");
		return execute(mapping, mcAuthoringForm, request, response);
	}

	
	/**
     * persists error messages to request scope
     * @param request
     * @param message
     */
	public void persistError(HttpServletRequest request, String message)
	{
		ActionMessages errors= new ActionMessages();
		errors.add(Globals.ERROR_KEY, new ActionMessage(message));
		logger.debug("add " + message +"  to ActionMessages:");
		saveErrors(request,errors);	    	    
	}
}  

