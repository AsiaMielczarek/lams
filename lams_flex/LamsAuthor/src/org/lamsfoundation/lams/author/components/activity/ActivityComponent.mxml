<?xml version="1.0" encoding="utf-8"?>
<mx:VBox xmlns:mx="http://www.adobe.com/2006/mxml"
	mouseDown="mouseDown(event)"
	mouseOver="mouseOver(event)" 
	mouseOut="mouseOut(event)"
	click="click(event)" 
	>

	<!--
	Root component for the activities. 
	All activities inherit from this component
	-->

	<mx:Script>
		<![CDATA[
			import mx.controls.Image;
			import org.lamsfoundation.lams.author.util.AuthorUtil;
			import org.lamsfoundation.lams.author.controller.AuthorController;
			import org.lamsfoundation.lams.author.components.activity.group.GroupActivityComponent;
			import mx.collections.ArrayCollection;
			import mx.core.UIComponent;
			import mx.controls.Alert;
			import mx.managers.DragManager;
			import mx.core.DragSource;
			import org.lamsfoundation.lams.author.util.Constants;
			import mx.core.Application;
			import org.lamsfoundation.lams.author.events.TransitionEvent;
			import mx.controls.Label;
			import org.lamsfoundation.lams.author.components.transition.TransitionComponent;
			
			// Activity UIID
			[Bindable]
			public var activityUIID:int;
			
			// Activity title label
			public var title:Label;
			
			// Center position of the activity component
			public var centerX:int;
			public var centerY:int;
			
			// Point of mouse during drag
			public var mouseOffSetX:int;
			public var mouseOffSetY:int;
			
			// Transtitions
			public var transitionIn:TransitionComponent
			public var transitionOut:TransitionComponent;
			
			// Grouping UUID 0 means no grouping
			[Bindable]
			public var groupingUIID:int = 0;
			
			// Activity states
			public var isDragable:Boolean = true;
			public var canStartTransitions:Boolean = true;  	// True if this activty can start transitions
			public var canAcceptTransitions:Boolean = true;		// True if this activty can accept transitions
			public var state:int = Constants.ACTIVITY_STATE_NORMAL;
			
			// Function used to load a new activity 
			public function load(UIID:int):void { 
				this.activityUIID = UIID;
		    }
		    
		    public function disableTitle():void {
		    	toolTip = title.text;
				title.visible = false;
				title.height = 0;
		    }
		    
		    // When you click on an activity, it becomes selected
		    // And the properties box appears
		    protected function click(event:MouseEvent):void {
		    	selectActivity();
				event.stopPropagation();
		    }
		    
		    public function selectActivity():void {
		    	
		    	// check the activity is loaded.
		    	if (title != null) {
		    		this.setStyle('borderStyle', 'solid');
					this.setStyle('borderColor', '#66CCFF');
					this.state = Constants.ACTIVITY_STATE_SELECTED;
					
					if (Application.application.selectedActivity != null) {
						Application.application.selectedActivity.deSelectActivity();
					}
					Application.application.selectedActivity = this;
					Application.application.canvasArea.propertyInspector.openPropertyInspector(this);
		    	}
		    }
		    
		    public function deSelectActivity():void {
		    	this.setStyle('borderStyle', 'none');
		    	this.state = Constants.ACTIVITY_STATE_NORMAL;
		    	
		    	if (Application.application.selectedActivity == this) {
		    		Application.application.selectedActivity = null;
		    		Application.application.canvasArea.propertyInspector.closePropertyInspector();
		    	}
		    }
		    

			/**
			 * The mouse down event handler
			 * Initiates drag of activity as well as starting a transition 
			 * depending on the cursor state
			 */
		    protected function mouseDown(event:MouseEvent):void {
		    	setCenter();
		    	
		    	switch (Application.application.cursorState) {
		    		case Constants.CURSOR_STATE_TRANSITION:
			    		if (this.canStartTransitions) {
			    			startTransition(event);
			    		}
		    			break;
		    		case Constants.CURSOR_STATE_NORMAL:
		        		startDragging(event);
				        break;	
		    	}
		    }
		    
		    /**
		    * Starts dragging the ActivityComponent
		    * 
		    */ 
		    public function startDragging(event:MouseEvent):void {
				var activityComponent:ActivityComponent = event.currentTarget as ActivityComponent;
					        
		        if (activityComponent.isDragable) {
		        	var ds:DragSource = new DragSource();
		        	//ds.addData(activityComponent, "img"); 
		        	ds.addData( activityComponent.parent, 'dragParent' );
					ds.addData( activityComponent, 'dragActivity' );
					
	                 
		        	// Set the offset for dropping the activity to the local mouse position
		        	activityComponent.mouseOffSetX = event.localX;
		        	activityComponent.mouseOffSetY = event.localY; 
		        	     
		        	DragManager.doDrag(activityComponent, ds, event, AuthorUtil.getImage(activityComponent));
		        } 
			}
		    
		    public function setCenter():void {
		    	centerX = x + height/2;
				centerY = y + height/2 -10;
		    }
		    
	        protected function startTransition(event:MouseEvent):void {
			 
				// Check if there is a pre-existing transition
				var possibleBranch:Boolean = transitionOut != null;
				var possibleFirstActivityInBranch:ActivityComponent = null;
				if (possibleBranch) {
					possibleFirstActivityInBranch = transitionOut.toActivity;
				}
				
				if (transitionOut != null) {
					//Alert.show(Application.application.dictionary.getLabelAndInsert("cv_invalid_trans_target_from_activity", [this.title.text]));
					
					// Return cursor state to normal
	    			//Application.application.changeCursorState(Constants.CURSOR_STATE_NORMAL);			
	    			//return;	
				} 
				
				state = Constants.ACTIVITY_STATE_DRAWING;

				Application.application.uiState = Constants.UI_STATE_DRAWING;
				transitionOut = new TransitionComponent();
				transitionOut.fromActivity = this;
				transitionOut.startX = centerX;
				transitionOut.startY = centerY;
				transitionOut.endX = centerX;
				transitionOut.endY = centerY;
				transitionOut.invalidateProperties();
				transitionOut.possibleBranch = possibleBranch;
				transitionOut.possibleFirstActivityInBranch = possibleFirstActivityInBranch;
				
				
				// deselect the currently selected activity
				if (Application.application.selectedActivity != null) {
					Application.application.selectedActivity.deSelectActivity();
				}
				
				parent.addChild(transitionOut);
				
				systemManager.addEventListener(MouseEvent.MOUSE_MOVE, systemManagerMouseMoveHandler, true);
				systemManager.addEventListener(MouseEvent.MOUSE_UP, systemManagerMouseUpHandler, true);
				systemManager.stage.addEventListener(Event.MOUSE_LEAVE, stageMouseLeaveHandler);
			
			}
			
			protected function stopTransition():void
			{
			    Application.application.uiState = Constants.UI_STATE_NORMAL;
			    systemManager.removeEventListener(MouseEvent.MOUSE_MOVE, systemManagerMouseMoveHandler, true);			
			    systemManager.removeEventListener(MouseEvent.MOUSE_UP, systemManagerMouseUpHandler, true);
			    systemManager.stage.removeEventListener(Event.MOUSE_LEAVE, stageMouseLeaveHandler);
			}
			
			private function systemManagerMouseMoveHandler(event:MouseEvent):void
		    {
		    	var pt:Point = new Point(event.stageX,event.stageY);
		    	pt = parent.globalToLocal(pt);
		    	
		    	transitionOut.endX = pt.x;
		    	transitionOut.endY = pt.y;
		    	
		    	transitionOut.invalidateDisplayList();
		    }
		    
		   
		    /**
		    * This event fires at the end of a transition.
		    * 
		    * Needs to be handled by the controller as it changes the learningDesing state
		    * 
		    */ 
		    private function systemManagerMouseUpHandler(event:MouseEvent):void
		    {
		    	stopTransition();
		    	
		    	var transitionEvent:TransitionEvent = new TransitionEvent(TransitionEvent.TRANSITION_COMPLETE);
	    		transitionEvent.sourceActivityComponent = this;
	    		transitionEvent.transition = transitionOut;
	    		Application.application.dispatchEvent(transitionEvent);
	    		
	    		AuthorController.instance.drawTransition(this, transitionOut);
		    	
		    }
		    
		    private function stageMouseLeaveHandler(event:MouseEvent):void
		    {
		    	stopTransition();
		    }
		    
		    private function mouseOver(event:MouseEvent):void {
				
				if (Application.application.uiState == Constants.UI_STATE_DRAWING && this.state != Constants.ACTIVITY_STATE_DRAWING && canAcceptTransitions) {
					this.setStyle('borderStyle', 'solid');
					this.setStyle('borderColor', '#66CCFF');
					this.state = Constants.ACTIVITY_STATE_MOUSE_OVER;
				}
				
			}
			
			private function mouseOut(event:MouseEvent):void {
				
				switch (state) {
					case Constants.ACTIVITY_STATE_MOUSE_OVER:
						this.setStyle('borderStyle', 'none');
						this.state = Constants.ACTIVITY_STATE_NORMAL;
						break;
				}
				
			}
			
			public function updateTransitionPositions():void {
				this.setCenter();
				if (transitionOut != null)
		   		{
		   			transitionOut.startX = centerX;
		   			transitionOut.startY = centerY;
		   			transitionOut.invalidateDisplayList();
		   		} 
		   		if (transitionIn != null) {
		   			transitionIn.endX = centerX;
		   			transitionIn.endY = centerY;
		   			transitionIn.invalidateDisplayList();
		   		}
			}
			
			/**
			 * Gets all the possible groupings for this activity
			 * 
			 * @return collection of all possible groupings for this activity
			 */
			public function get allPossibleGroupings():ArrayCollection {	
				var ret:ArrayCollection = new ArrayCollection();
				if (this.transitionIn != null){
					var activity:ActivityComponent = this.transitionIn.fromActivity;
					
					while (true) {
						if (activity is GroupActivityComponent) {
							var entry:Object = new Object();
							entry.activityUIID = activity.activityUIID;
							entry.title = activity.title.text;
							ret.addItem(entry);
						}
						
						if (activity.transitionIn != null) {
							activity = activity.transitionIn.fromActivity;
						} else {
							break;
						}
					}  
				}
				
				return ret;
			}

		]]>
	</mx:Script>
	
	
</mx:VBox>
