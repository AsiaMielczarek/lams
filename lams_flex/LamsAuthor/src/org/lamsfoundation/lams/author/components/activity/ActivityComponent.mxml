<?xml version="1.0" encoding="utf-8"?>
<mx:VBox xmlns:mx="http://www.adobe.com/2006/mxml"
	mouseDown="mouseDown(event)"
	mouseOver="mouseOver(event)" 
	mouseOut="mouseOut(event)"
	mouseMove="mouseMove(event)"
	dragComplete="dragComplete(event)"
	click="click(event)"
	>

	<!--
	Root component for the activities. 
	All activities inherit from this component
	-->

	<mx:Script>
		<![CDATA[
			import org.lamsfoundation.lams.author.model.activity.Activity;
			import mx.controls.Image;
			import org.lamsfoundation.lams.author.util.AuthorUtil;
			import org.lamsfoundation.lams.author.controller.AuthorController;
			import org.lamsfoundation.lams.author.controller.TransitionController;
			import org.lamsfoundation.lams.author.components.activity.group.GroupActivityComponent; 
			import mx.collections.ArrayCollection;
			import mx.core.UIComponent;
			import mx.controls.Alert;
			import mx.managers.DragManager;
			import mx.core.DragSource;
			import org.lamsfoundation.lams.author.util.Constants;
			import mx.core.Application;
			import org.lamsfoundation.lams.author.events.TransitionEvent;
			import mx.controls.Label;
			import org.lamsfoundation.lams.author.components.transition.TransitionComponent;
			
			[Bindable] protected var _activity:Activity;
			
			// Point of mouse during drag
			public var mouseOffSetX:int;
			public var mouseOffSetY:int;
		
			// Center position of the activity component
			[Bindable] public var centerX:int;
			[Bindable] public var centerY:int;
			
			// Transition components, need a reference so we can move the transitions with the component
			public var transitionToComponent:TransitionComponent
			public var transitionFromComponent:TransitionComponent;
			
			// Grouping UUID 0 means no grouping
			//[Bindable] public var groupingUIID:int = 0;
			
			// Activity states
			public var isDragable:Boolean = true;
			public var canStartTransitions:Boolean = true;  	// True if this activty can start transitions
			public var canAcceptTransitions:Boolean = true;		// True if this activty can accept transitions
			[Bindable] public var state:int = Constants.ACTIVITY_STATE_NORMAL;
		    
		    // When you click on an activity, it becomes selected
		    // And the properties box appears
		    protected function click(event:MouseEvent):void {
		    	AuthorController.instance.selectActivityComponent(this);
				event.stopPropagation();
		    }
		    
		    public function selectActivity():void {
				// check the activity is loaded.
		    	if (_activity.title != null) {
		    		//this.setStyle('borderStyle', 'solid');
					//this.setStyle('borderColor', '#66CCFF');
					this.setStyle('backgroundColor', '#6699FF');
					this.state = Constants.ACTIVITY_STATE_SELECTED;
		    	}
		    }
		    
		    public function deSelectActivity():void {
		    	this.setStyle('backgroundColor', undefined);
		    	this.state = Constants.ACTIVITY_STATE_NORMAL;
		    	
		    }
		    
		 	/**
		 	 * The mouseMove event starts a drag
		 	 */ 
		    protected function mouseMove(event:MouseEvent):void {
		    	//startDragging(event);
		    	this.updateTransitionPositions();
		    }

			/**
			 * The mouse down event handler starts a transition 
			 */
		    protected function mouseDown(event:MouseEvent):void {
		    	setCenter();
		    	
		    	switch (AuthorController.instance.cursorState) {
		    		case Constants.CURSOR_STATE_TRANSITION:
			    		if (this.canStartTransitions) {
			    			TransitionController.instance.startTransition(event, this);
			    		}
		    			break;
		    		case Constants.CURSOR_STATE_NORMAL: {
		    			AuthorController.instance.selectActivityComponent(this);
		    			startDragging(event);
		    		}
		    	}
		    }
		    
		    /**
		    * Starts dragging the ActivityComponent
		    * 
		    */ 
		    public function startDragging(event:MouseEvent):void {
				// Can't do a drag if the mouse isn't down
				if (!(event.type == MouseEvent.MOUSE_DOWN ||
					  event.type == MouseEvent.CLICK ||
					  DragManager.isDragging ||
					  event.buttonDown))
				{
					return;
				}
				
				var activityComponent:ActivityComponent = event.currentTarget as ActivityComponent;
					        
		        if (activityComponent.isDragable && AuthorController.instance.cursorState != Constants.CURSOR_STATE_TRANSITION) {
		        	var ds:DragSource = new DragSource();
					ds.addData( activityComponent, 'dragActivity' );
					 
		        	// Need to get stage coords and convert since localX,Y is returning wrong values
		        	var point:Point = new Point(event.stageX, event.stageY);
		        	point = this.globalToLocal(point);
		        	
		        	// Set the offset for dropping the activity to the local mouse position
		        	activityComponent.mouseOffSetX = point.x;
		        	activityComponent.mouseOffSetY = point.y; 
		        	
		        	DragManager.doDrag(activityComponent, ds, event, AuthorUtil.getImage(activityComponent.getChildAt(0)), -3, -3, 1.0, false);
		        	activityComponent.visible = false;    
		        } 
			}
			
			protected function dragComplete(event:MouseEvent):void {
		    	var dragInitiator:ActivityComponent = event.currentTarget as ActivityComponent; 
		    	dragInitiator.visible = true;     
		    }
		    
		    public function setCenter():void {
	    		centerX = x + width/2;
				centerY = y + height/2;
		    }
		    

		    private function mouseOver(event:MouseEvent):void {
				if (AuthorController.instance.uiState == Constants.UI_STATE_DRAWING && this.state != Constants.ACTIVITY_STATE_DRAWING && canAcceptTransitions) {
					this.setStyle('backgroundColor', '#6699FF');
					this.state = Constants.ACTIVITY_STATE_MOUSE_OVER;
				}
			}
			
			private function mouseOut(event:MouseEvent):void {
				
				switch (state) {
					case Constants.ACTIVITY_STATE_MOUSE_OVER:
						this.setStyle('backgroundColor', undefined);
						this.state = Constants.ACTIVITY_STATE_NORMAL;
						break;
				}
				
			}
			
			public function updateTransitionPositions():void {
				this.setCenter();
				if (this.transitionFromComponent != null)
		   		{
		   			this.transitionFromComponent.startX = centerX;
		   			this.transitionFromComponent.startY = centerY;
		   			this.transitionFromComponent.invalidateDisplayList();
		   		} 
		   		if (this.transitionToComponent != null) {
		   			this.transitionToComponent.endX = centerX;
		   			this.transitionToComponent.endY = centerY;
		   			this.transitionToComponent.invalidateDisplayList();
		   		}
			}
			
			/**
			 * Gets all the possible groupings for this activity
			 * 
			 * @return collection of all possible groupings for this activity
			 */
			public function get allPossibleGroupings():ArrayCollection {	
				/* var ret:ArrayCollection = new ArrayCollection();
				if (this.transitionIn != null){
					var activityCmp:ActivityComponent = this.transitionIn.fromActivity;
					
					while (true) {
						if (activityCmp is GroupActivityComponent) {
							var entry:Object = new Object();
							entry.activity.activityUIID = activityCmp.activity.activityUIID;
							entry.activity.title = activityCmp.activity.title;
							ret.addItem(entry);
						}
						
						if (activityCmp.transitionIn != null) {
							activityCmp = activityCmp.transitionIn.fromActivity;
						} else {
							break;
						}
					}  
				}
				
				return ret; */
				
				return null;
			}
			
			[Bindable]
			public function get title():String {
				return _activity.title;
			}
			
			public function set title(title:String):void {
				_activity.title = title;
			}
			
			public function get activityTypeID():int {
				return _activity.activityTypeID;
			}
			
			/**
			 * Returns the root activity object
			 * This is required as AS3 has not concept of abstract methods.
			 * So we need to be able to fetch this activity instance
			 * Without knowing what activity type it is.
			 */ 
			public function get rootActivity():Activity {
				return _activity;
			}

		]]>
	</mx:Script>
	
	<mx:Binding source="_activity.xCoord" destination="this.x" />
	<mx:Binding source="_activity.yCoord" destination="this.y" />
</mx:VBox>
