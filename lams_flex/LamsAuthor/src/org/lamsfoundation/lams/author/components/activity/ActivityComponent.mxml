<?xml version="1.0" encoding="utf-8"?>
<mx:VBox xmlns:mx="http://www.adobe.com/2006/mxml"
	mouseMove="mouseMove(event)"
	mouseDown="mouseDown(event)"
	mouseOver="mouseOver(event)" 
	mouseOut="mouseOut(event)"
	>

	<!--
	Root component for the activities. 
	All activities inherit from this component
	-->

	<mx:Script>
		<![CDATA[
			import mx.managers.DragManager;
			import mx.core.DragSource;
			import org.lamsfoundation.lams.author.util.Constants;
			import mx.core.Application;
			import org.lamsfoundation.lams.author.events.TransitionEvent;
			import mx.controls.Label;
			import org.lamsfoundation.lams.author.components.transition.TransitionComponent;
			
			// Activity title label
			public var title:Label;
			
			// Center position of the activity component
			public var centerX:int;
			public var centerY:int;
			
			// Point of mouse during drag
			public var mouseOffSetX:int;
			public var mouseOffSetY:int;
			
			// Transtitions
			public var transitionIn:TransitionComponent
			public var transitionOut:TransitionComponent;
			
			// Activity states
			public var isDragable:Boolean = true;
			public var canStartTransitions:Boolean = true;  	// True if this activty can start transitions
			public var canAcceptTransitions:Boolean = true;		// True if this activty can accept transitions
			public var state:int = Constants.ACTIVITY_STATE_NORMAL;
			
			// Function used to load a new activity 
			public function load():void { 	
		    }
		    
		    public function disableTitle():void {
		    	toolTip = title.text;
				title.visible = false;
				title.height = 0;
		    }
		    
			
			// The mouseMove event handler for the Image control
		    // initiates the drag-and-drop operation.
		    protected function mouseMove(event:MouseEvent):void 
		    {                
		        switch (Application.application.cursorState) {
		        	case Constants.CURSOR_STATE_NORMAL:
		        		
		        		var activityComponent:ActivityComponent = event.currentTarget as ActivityComponent;
				        
				        if (activityComponent.isDragable) {
				        	var ds:DragSource = new DragSource();
				        	ds.addData(activityComponent, "img"); 
				        	
				        	// Set the offset for dropping the activity to the local mouse position
				        	activityComponent.mouseOffSetX = event.localX;
				        	activityComponent.mouseOffSetY = event.localY;  
				        	
				        	this.setStyle('borderStyle', 'solid');
							this.setStyle('borderColor', '#66CCFF');         
				        	
				        	DragManager.doDrag(activityComponent, ds, event);
				        	setCenter();
				        }
				        break;
		        }
		    }

		    protected function mouseDown(event:MouseEvent):void {
		    	
		    	switch (Application.application.cursorState) {
		    		case Constants.CURSOR_STATE_TRANSITION:
			    		if (this.canStartTransitions) {
			    			startDragging(event);
			    		}
			    		
		    			break;	
		    	}
		    	
		    }
		    
		    public function setCenter():void {
		    	centerX = x + height/2;
				centerY = y + height/2 -10;
		    }
		    
	        protected function startDragging(event:MouseEvent):void {
			 
				if (transitionOut != null) {
					parent.removeChild(transitionOut);
				}
				
				setCenter();
				
				state = Constants.ACTIVITY_STATE_DRAWING;

				Application.application.uiState = Constants.UI_STATE_DRAWING;
				transitionOut = new TransitionComponent();
				transitionOut.startX = centerX;
				transitionOut.startY = centerY;
				transitionOut.endX = centerX;
				transitionOut.endY = centerY;
				transitionOut.invalidateProperties();
				
				parent.addChild(transitionOut);
				
				systemManager.addEventListener(MouseEvent.MOUSE_MOVE, systemManagerMouseMoveHandler, true);
				systemManager.addEventListener(MouseEvent.MOUSE_UP, systemManagerMouseUpHandler, true);
				systemManager.stage.addEventListener(Event.MOUSE_LEAVE, stageMouseLeaveHandler);
			
			}
			
			protected function stopDragging():void
			{
			    Application.application.uiState = Constants.UI_STATE_NORMAL;
			    systemManager.removeEventListener(MouseEvent.MOUSE_MOVE, systemManagerMouseMoveHandler, true);			
			    systemManager.removeEventListener(MouseEvent.MOUSE_UP, systemManagerMouseUpHandler, true);
			    systemManager.stage.removeEventListener(Event.MOUSE_LEAVE, stageMouseLeaveHandler);
			    this.setStyle('borderStyle', 'none');
			}
			
			private function systemManagerMouseMoveHandler(event:MouseEvent):void
		    {
		    	var pt:Point = new Point(event.stageX,event.stageY);
		    	pt = parent.globalToLocal(pt);
		    	
		    	transitionOut.endX = pt.x;
		    	transitionOut.endY = pt.y;
		    	
		    	transitionOut.invalidateDisplayList();
		    }
		    
		   
		    /**
		    * This event fires at the end of a transition.
		    * 
		    * Needs to be handled by the controller as it changes the learningDesing state
		    * 
		    */ 
		    private function systemManagerMouseUpHandler(event:MouseEvent):void
		    {
		    	stopDragging();
		    	
		    	
		    	var transitionEvent:TransitionEvent = new TransitionEvent(TransitionEvent.TRANSITION_EVENT);
	    		transitionEvent.sourceAcivityComponent = this;
	    		transitionEvent.transition = transitionOut;
	    		//transitionEvent.localX = event.localX;
	    		//transitionEvent.localY = event.localY;
	    		Application.application.dispatchEvent(transitionEvent);
		    	
		    	
		    	/* var validTransition:Boolean = false;
		    	for (var i:int = 0; i < parent.numChildren; i++) {
		    		
		    		if (parent.getChildAt(i) is ActivityComponent) {
		    			
		    			var activityComponent:ActivityComponent = parent.getChildAt(i) as ActivityComponent;
		    			if (activityComponent.state == Constants.ACTIVITY_STATE_MOUSE_OVER && activityComponent.canAcceptTransitions) {
		    				activityComponent.transitionIn = transitionOut;	
		    				validTransition = true;		
		    			}
		    		}
		    	}
		    	
		    	if (!validTransition) {
		    		transitionOut.graphics.clear();
		    		parent.removeChild(transitionOut);
		    		transitionOut = null;
		    		
		    		
		    	}
		    	else {
		    		// Return cursor state to normal
					Application.application.changeCursorState(Constants.CURSOR_STATE_NORMAL);
					updateTransitionPositions();
		    	} */
		    	
		    }
		    
		    private function stageMouseLeaveHandler(event:MouseEvent):void
		    {
		    	stopDragging();
		    }
		    
		    private function mouseOver(event:MouseEvent):void {
				
				if (Application.application.uiState == Constants.UI_STATE_DRAWING && this.state != Constants.ACTIVITY_STATE_DRAWING && canAcceptTransitions) {
					this.setStyle('borderStyle', 'solid');
					this.setStyle('borderColor', '#66CCFF');
					this.state = Constants.ACTIVITY_STATE_MOUSE_OVER;
				}
				
			}
			
			private function mouseOut(event:MouseEvent):void {
				this.setStyle('borderStyle', 'none');
			}
			
			public function updateTransitionPositions():void {
				this.setCenter();
				if (transitionOut != null)
		   		{
		   			transitionOut.startX = centerX;
		   			transitionOut.startY = centerY;
		   			transitionOut.invalidateDisplayList();
		   		} 
		   		if (transitionIn != null) {
		   			transitionIn.endX = centerX;
		   			transitionIn.endY = centerY;
		   			transitionIn.invalidateDisplayList();
		   		}
			}

			
		]]>
	</mx:Script>
	
	
</mx:VBox>
