<?xml version="1.0" encoding="utf-8"?>
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml"
	xmlns:ns1="org.lamsfoundation.lams.common.ui.components.*"
	xmlns:ns2="*"
	layout="absolute" 	backgroundGradientAlphas="[1.0, 1.0]" backgroundGradientColors="[#FFFFFF, #FFFFFF]" width="361" height="331"
	enabled="false"
	preinitialize="onPreinitialize(event)"
	applicationComplete="onApplicationComplete(event)">
		
	<mx:Script>
		<![CDATA[
			import mx.events.CloseEvent;
			import mx.core.UIComponent;
			import org.lamsfoundation.lams.common.managers.LamsAjaxOverlayManager;
			import org.lamsfoundation.lams.common.conn.ImageService;
			import org.lamsfoundation.lams.common.util.ScreenShotterEvent;
						
			//includes
			include "HTTPServices.as"
			
			// imports
			import mx.managers.PopUpManager;
			import org.lamsfoundation.lams.common.util.VideoDisplayUtil;
			import mx.containers.ControlBar;
			import mx.effects.easing.Elastic;
			import mx.effects.AddChildAction;
			import mx.states.AddChild;
			import mx.controls.TabBar;
			import org.lamsfoundation.lams.common.ui.components.VideoDisplayEvent;
			import mx.events.SliderEvent;
			import mx.controls.Button;
			import mx.controls.Alert;
			import org.lamsfoundation.lams.common.dictionary.XMLDictionary;
			import flash.external.*;
			import org.lamsfoundation.lams.common.util.LAMSStringUtil;
			import mx.containers.TitleWindow;
			
			// flashvars
			[Bindable] private var mode:String;
			private var offlinePlayback:Boolean;
			private var red5ServerUrl:String;
			private var red5RecordingsUrl:String;
			private var saveToLamsDestUrl:String;
			private var contentFolderUrl:String;
			private var lamsEarDir:String;
			private var serverUrl:String;
			private var filename:String;
			private var toolContentId:int;
			private var userId:int;
			private var languageXML:XML;
			private var toolServletUrl:String;
			private var saveToLamsServletUrl:String;
			
			// needed stuff
			private var dictionary:XMLDictionary;
			private var nc:NetConnection;
			private var playTimer:Timer;
			private var recTimer:Timer;
			private var cam:Camera;
			private var mic:Microphone;
			private var languageTimer:Timer;
			private var getDetailsPopUp:GetRecordingDetailsPopUp;
			private var alertCount:uint = 0;
			
			// static strings
			private static var red5App:String = "oflaDemo";
			private static var toolWWWDir:String = "tool/lavidr10/";
			private static var toolServletLocation:String = "videoRecorderActions.do";
			private static var saveToLamsServletLocation:String = "GetRecording";
			private static var flvExtension:String = ".flv";
			
			// icon embeds
			[Embed(source="assets/images/control_play.png")] [Bindable] private var playIcon:Class;
			[Embed(source="assets/images/control_pause.png")] [Bindable] private var pauseIcon:Class;
			[Embed(source="assets/images/control_record.png")] [Bindable] private var recordIcon:Class;
			[Embed(source="assets/images/accept.png")] [Bindable] private var saveIcon:Class;
			
			// called first of all, before any components are initialized
			private function onPreinitialize(event:Event):void{
				// get flashvars
				getFlashVars();
				
				// for testing purposes (when running in debug)
				if(mode == null){
					red5ServerUrl = new String("rtmp://localhost/");
					serverUrl = new String("http://localhost:8080/lams/");
					mode = new String("recorderModeAuthor");
					toolContentId = 1;
				}
			}
			
			// add the appropriate controlbar, called after the videoDisplay component is added to the panel container
			private function addControlBar(event:Event):void{
				// create the video control bar
				videoControlBar = new VideoControlBar();
				
				// give it the mode so it can delete buttons once created
				videoControlBar.mode = mode;
				
				// add the control bar now, before the panel is added, so the control bar is anchored
				videoDisplayPanel.addChild(videoControlBar);
			}
			
			// general alert listener for cam/mic alerts on startup
			private function alertListener(event:CloseEvent):void {
            	alertCount--;
            	if(alertCount == 0 && nc == null) createConnection(); 
            }
			
			// called after everything is created and ready to go
			private function onApplicationComplete(event:Event):void {
				LamsAjaxOverlayManager.showOverlay(UIComponent(Application.application));
				// add an external interface callback to all setLanguageXML to be called from js
				ExternalInterface.addCallback("setLanguageXML", setLanguageXML);					
				
				// init labels if languageXML is not empty
				if(languageXML.toString() != ""){
					setLanguageXML(languageXML);
				}
				else{
					// create a placeholder dictionary
					dictionary = new XMLDictionary(new XML(""));
					
					// attempt to get the dictionary via servlet
					getLanguageXMLFromServer();
				}
				
				// set button icons
				setIcons();
				
				// init buttons states
				videoControlBar.playButton.enabled = false;
				videoControlBar.seekSlider.enable(false);
				videoControlBar.saveAndCloseButton.enabled = false;
				
				// add listeners
				addListeners();
				
				// add the app name to the red5 url to complete the url
				red5ServerUrl += red5App;
				
				// add the tool servlet location
				toolServletUrl = serverUrl + toolWWWDir + toolServletLocation;
				
				// add the save to lams servlet location
				saveToLamsServletUrl = serverUrl + saveToLamsServletLocation;
				
				// add server url and servlet url to video display
				videoDisplay.serverUrl = serverUrl;
				videoDisplay.servletUrl = toolServletUrl;
								
				// swtich on mode
				switch(mode){
					/*
					In playerModeOnline mode, the parameters passed via flashVars are used to create a connection to a given Red5 server.
					Video is streamed from that server to the user.
					*/
					case "playerModeOnline":{
						createConnection();
						break;
					}
					/*
					In playerModeOffline mode, a null NetConnection object is used to play local video from the disk.
					*/
					case "playerModeOffline":{
						LamsAjaxOverlayManager.hideOverlay(UIComponent(Application.application));
						videoDisplay.makeReady(filename, "video", true);
						break;
					}
					/*
					In recorderModeFCK mode, a NetConnection is created to the given Red5 server. Video is streamed and recorded
					on this server. It is then copied back to the LAMS server in the lesson's content folder for local reading
					much like an attachment is added to the FCKEditor.
					*/
					case "recorderModeFCK":{
						toolContentId = -1;
						
						if(!isWebcamInfoSet())
						{
							Security.showSettings();
							setWebcamInfo(true);
						}
						
						// set up camera
						cam = VideoDisplayUtil.setupCamera();

						// set up mic
						mic = VideoDisplayUtil.setupMic();
						
						checkCamera()
						checkMic();
						
						// don't allow recording if neither cam nor mic is enabled
						if(!mic && !cam){
							videoControlBar.recordButton.enabled = false;
						}
						
						if(alertCount <= 0) createConnection();
						
						break;
					}
					/*
					In recorderModeAuthor mode, a NetConnection is created to the given Red5 server. Video is streamed and recorded
					on this server. It is then used in a VideoRecorder tool session. After it is recorded, it is immediately transfered back to
					the LAMS server in case the lesson is exported.
					*/
					case "recorderModeAuthor":{
						userId = -1;
						
						if(!isWebcamInfoSet())
						{
							Security.showSettings();
							setWebcamInfo(true);
						}
						
						// set up camera
						cam = VideoDisplayUtil.setupCamera();
						
						// set up mic
						mic = VideoDisplayUtil.setupMic();
						
						checkCamera()
						checkMic();
						
						// don't allow recording if neither cam nor mic is enabled
						if(!mic && !cam){
							videoControlBar.recordButton.enabled = false;
						}
												
						if(alertCount <= 0) createConnection();

						break;
					}
				}
			}
			
			private function checkCamera():Boolean {
				if(cam){
					videoDisplay.attachCamera(cam);
				}
				else{
					Alert.show(dictionary.getLabel("videorecorder.camera.not.available"), "", Alert.OK, Sprite(Application.application), alertListener);
					alertCount++;
					return false;
				}
				
				return true;	
			}
			
			private function checkMic():Boolean {
				if(mic){
					videoDisplay.attachMic(mic);
				}
				else{
					Alert.show(dictionary.getLabel("videorecorder.mic.not.available"), "", Alert.OK, Sprite(Application.application), alertListener);
					alertCount++;
					return false;
				}
				
				return true;
			}
						
			// sets language xml, usually called at a later time through javascript
			public function setLanguageXML(languageXMLString:String):void{
				if(languageXMLString != "" || languageXMLString != null){
					try{
						languageXML = XML(languageXMLString);
					}
					catch(e:Error){
						languageXML = XML(unescape(languageXMLString));
					}
					
					dictionary = new XMLDictionary(languageXML);
					setLabels();
					setTooltips();
				}
			}
			
			// adds some listeners
			private function addListeners():void{
				videoDisplay.addEventListener(VideoDisplayEvent.METADATA, onMetaData);
				videoDisplay.addEventListener(VideoDisplayEvent.PAUSE, onPause);
				videoDisplay.addEventListener(VideoDisplayEvent.UNPAUSE, onUnpause);
				videoDisplay.addEventListener(VideoDisplayEvent.READY, onReady);
				videoDisplay.addEventListener(VideoDisplayEvent.COMPLETE, onComplete);
				videoDisplay.addEventListener(VideoDisplayEvent.STARTPUBLISH, onStartPublish);
				videoDisplay.addEventListener(VideoDisplayEvent.STOPPUBLISH, onStopPublish);
				videoDisplay.addEventListener(VideoDisplayEvent.PAUSESEEK, onPauseSeek);
				videoDisplay.addEventListener(VideoDisplayEvent.READYSEEK, onReadySeek);	
				this.addEventListener(ScreenShotterEvent.SCREENSHOTTAKEN, onScreenShotTaken);
				
				videoControlBar.playButton.addEventListener(MouseEvent.CLICK, playClick);
				
				videoControlBar.seekSlider.addEventListener(SliderEvent.THUMB_PRESS, onSeekPress);
				videoControlBar.seekSlider.addEventListener(SliderEvent.THUMB_RELEASE, onSeekRelease);
				
				switch(mode){
					case "recorderModeFCK":{
						videoControlBar.recordButton.addEventListener(MouseEvent.CLICK, recordClick);
						videoControlBar.saveAndCloseButton.addEventListener(MouseEvent.CLICK, saveAndCloseClick);
						break;
					}
					case "recorderModeAuthor":{
						videoControlBar.recordButton.addEventListener(MouseEvent.CLICK, recordClick);
						break;
					}
				}
			}
			
			// sets initial labels
			private function setLabels():void{
				if(mode == "playerModeOnline" || mode == "playerModeOffline"){
					videoDisplayPanel.title = dictionary.getLabel("videorecorder.video.player");
				}
				else if(mode == "recorderModeFCK"){
					videoDisplayPanel.title = dictionary.getLabel("videorecorder.video.recorder");
				}
				
				videoDisplayPanel.status = dictionary.getLabel("videorecorder.waiting");
			}
			
			// sets initial tooltips
			private function setTooltips():void{
				switch(mode){
					case "playerModeOnline":{
						videoControlBar.playButton.toolTip = dictionary.getLabel("videorecorder.tooltip.play");
						break;
					}
					case "playerModeOffline":{
						videoControlBar.playButton.toolTip = dictionary.getLabel("videorecorder.tooltip.play");
						break;
					}
					case "recorderModeFCK":{
						videoControlBar.playButton.toolTip = dictionary.getLabelAndConcatenate("videorecorder.tooltip.play", [" (", dictionary.getLabel("videorecorder.disabled"), ")"]);
						videoControlBar.recordButton.toolTip = dictionary.getLabel("videorecorder.tooltip.start.recording");
						videoControlBar.saveAndCloseButton.toolTip = dictionary.getLabelAndConcatenate("videorecorder.tooltip.save.recording", [" (", dictionary.getLabel("videorecorder.disabled"), ")"]);
						break;
					}
					case "recorderModeAuthor":{
						videoControlBar.playButton.toolTip = dictionary.getLabelAndConcatenate("videorecorder.tooltip.play", [" (", dictionary.getLabel("videorecorder.disabled"), ")"]);
						videoControlBar.recordButton.toolTip = dictionary.getLabel("videorecorder.tooltip.start.recording");
						break;
					}
				}
			}
			
			// sets initial icons
			private function setIcons():void{
				videoControlBar.playButton.setStyle("icon", playIcon);
				videoControlBar.recordButton.setStyle("icon", recordIcon);
				videoControlBar.saveAndCloseButton.setStyle("icon", saveIcon);
			}
			
			// gets flashvars
			private function getFlashVars():void{
				mode = Application.application.parameters.mode;
				offlinePlayback = LAMSStringUtil.stringToBool(Application.application.parameters.offlinePlayback);
				red5ServerUrl = Application.application.parameters.red5ServerUrl;
				serverUrl = Application.application.parameters.serverUrl;
				filename = Application.application.parameters.filename;
				languageXML = XML(Application.application.parameters.languageXML);
				toolContentId = Application.application.parameters.toolContentId;
				userId = Application.application.parameters.userId;
				red5RecordingsUrl = Application.application.parameters.red5RecordingsUrl;
				saveToLamsDestUrl = Application.application.parameters.saveToLamsDestUrl;
				lamsEarDir = Application.application.parameters.lamsEarDir;
				contentFolderUrl = Application.application.parameters.contentFolderUrl;
			}
			
			// checks for previous webcam info
			private function isWebcamInfoSet():Boolean{
				var lamsVideoRecorderInfo:Object = SharedObject.getLocal("lamsWebcamInfo");
				
				if(lamsVideoRecorderInfo.data.webcamSet){
					return lamsVideoRecorderInfo.data.webcamSet;
				}else{
					return false;
				}
					
			}
			
			// sets webcam info
			private function setWebcamInfo(checked:Boolean):void{
				var lamsVideoRecorderInfo:Object = SharedObject.getLocal("lamsWebcamInfo");
				lamsVideoRecorderInfo.data.webcamSet = checked;
			}
			
			// creates a netconnection if it is needed
			private function createConnection():void{
				// create basic netConnection object
				nc = new NetConnection();
			
				// add some listeners to it
				nc.addEventListener(NetStatusEvent.NET_STATUS, ncStatusHandler);
				nc.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
				nc.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);
				
				// set the nc to the videodisplay
				videoDisplay.setNetConnection(nc);
				
				// connect to the local Red5 server and wait for callback
				nc.connect(red5ServerUrl);
				
				// wait for NetStatusEvent to be thrown
			}
			
			// callback called on NetConnection connect event
			private function ncStatusHandler(event:NetStatusEvent):void {
				// get the info object
				var infoObject:Object = event.info;
	  
				// if successful connection
				if (infoObject.code == "NetConnection.Connect.Success") {
					// enable application
					LamsAjaxOverlayManager.hideOverlay(UIComponent(Application.application));
					
					// if we are in a player online instance
					if(mode == "playerModeOnline"){
						// extension added from fck record
						if(mic && !cam) videoDisplay.makeReady(filename, "audio", false);
						else  videoDisplay.makeReady(filename, "video", false);
					}
					// if we are in fck mode
					else if(mode == "recorderModeFCK"){
						videoDisplay.startViewCamera();
					}
					// if we are in recorder mode and have no input filename
					else if(mode == "recorderModeAuthor" && filename == flvExtension){
						videoDisplay.startViewCamera();
					}
					// if we are in author mode and are given a filename, don't start camera, play recording instead
					else if(mode == "recorderModeAuthor" && filename != flvExtension){
						// add on to the filename if offlinePlayback is active
						if(offlinePlayback){
							filename = contentFolderUrl + filename;
						}
						
						// change the start recording button's label
						if(mic && !cam) videoDisplay.makeReady(filename, "audio", offlinePlayback);
						else videoDisplay.makeReady(filename, "video", offlinePlayback);
						
						// update tooltip
						videoControlBar.recordButton.toolTip = dictionary.getLabel("videorecorder.tooltip.start.recording.again");
					}

				}
				// if connection unsuccessful
				else if(infoObject.code == "NetConnection.Connect.InvalidApp"){		
					// pop an alert
					Alert.show("Web appplication not available");
				}
				else if(infoObject.code == "NetConnection.Connect.Failed"){
					// pop an alert
					Alert.show("NetConnection not connected");
				}
				else if(infoObject.code == "NetConnection.Connect.Closed"){
					// pop an alert
					Alert.show("NetConnection closed");
				}
			}
			
			// netconnection security error handler
			private function securityErrorHandler(event:SecurityErrorEvent):void {
				trace("securityErrorHandler: " + event);
			}
			
			// netconnection async error handler
			private  function asyncErrorHandler(event:AsyncErrorEvent):void {
				trace("securityErrorHandler: " + event);
			} 
	    	
        	// bw detection handler
			public function onBWDone(infoObject:Object):void {
				// print its properties
    			trace(VideoDisplayUtil.printInfoObject(infoObject, "onBWDone"));
			}
			
			// play button click handler
			private function playClick(event:MouseEvent):void{
				videoDisplay.play();
			}

        	// handler called when the confirm action ("ok", "cancel", "save") on a popup is hit
        	private function popUpRemovedHandler(event:Event):void{
        		// if the given popup is of type getDetailsPopUp
        		if(event.target == getDetailsPopUp){
        			// get the details
        			var title:String = getDetailsPopUp.titleInput.text;
        			var description:String = getDetailsPopUp.descriptionInput.text;
        			
        			// call the http service to save a recording
        			saveRecordingToServer(title, description, filename, toolContentId);
        		}
        		
        		if(event.target is TitleWindow){
        			PopUpManager.removePopUp(TitleWindow(event.target));
        		}
        	}
        	
			// record button click handler
			private function recordClick(event:MouseEvent):void{
				if(!videoDisplay.isPublishing){
					if(mode == "recorderModeFCK"){
						filename = VideoDisplayUtil.createFilenameForFCK(userId);
						videoDisplay.startPublish(filename, false);
					}
					else if(mode == "recorderModeAuthor"){
						filename = VideoDisplayUtil.createFilenameForAuthor(toolContentId);
						videoDisplay.startPublish(filename, true);
					}		
				}
				else if(videoDisplay.isPublishing)
					videoDisplay.stopPublish();
			}
			
			// save and close button click handler
			private function saveAndCloseClick(event:MouseEvent):void{
				var eventObj:Object = new Object();
			 	eventObj.filename = contentFolderUrl + filename + ".flv";
				eventObj.red5ServerUrl = red5ServerUrl;
				eventObj.mode = "playerModeOffline";
				eventObj.languageXML = languageXML.toXMLString();

				ExternalInterface.call("saveToFCKEditor", eventObj); 
			}
			
			// onMetaData callback, called from videoDisplay
			private function onMetaData(event:VideoDisplayEvent):void{
				videoDisplayPanel.status = dictionary.getLabel("videorecorder.buffering");
				videoControlBar.seekSlider.setMiniMaxValues(0, event.metadata.duration);
				videoControlBar.seekSlider.setValue(0);
				videoControlBar.seekSlider.startTimerLabel();
			}
			
			// onReady callback, called from videoDisplay
			private function onReady(event:VideoDisplayEvent):void{
				videoControlBar.playButton.enabled = true;
				videoControlBar.seekSlider.enable(true);
				videoControlBar.playButton.setStyle("icon", playIcon);
				videoControlBar.playButton.toolTip = dictionary.getLabel("videorecorder.tooltip.play");
				videoDisplayPanel.status = dictionary.getLabel("videorecorder.ready");
			}
			
			// onUnpause callback, called from videoDisplay
			private function onUnpause(event:VideoDisplayEvent):void{
				videoControlBar.playButton.setStyle("icon", pauseIcon);
				videoControlBar.playButton.toolTip = dictionary.getLabel("videorecorder.tooltip.pause");
				videoDisplayPanel.status = dictionary.getLabel("videorecorder.playing");
			}
			
			// onPause callback, called from videoDisplay
			private function onPause(event:VideoDisplayEvent):void{
				videoControlBar.playButton.setStyle("icon", playIcon);
				videoControlBar.playButton.toolTip = dictionary.getLabel("videorecorder.tooltip.resume");
				videoDisplayPanel.status = dictionary.getLabel("videorecorder.paused");
			}
			
			// onComplete callback, called from videoDisplay
			private function onComplete(event:VideoDisplayEvent):void{
				videoControlBar.playButton.setStyle("icon", playIcon);
				videoControlBar.playButton.toolTip = dictionary.getLabel("videorecorder.tooltip.play");
				videoDisplayPanel.status = dictionary.getLabel("videorecorder.ready");
			}
			
			// onStartPublish callback, called from videoDisplay
			private function onStartPublish(event:VideoDisplayEvent):void{
				// stop the timer if it is created
				if(playTimer)
					playTimer.stop();
					
				videoControlBar.playButton.enabled = false;
				videoControlBar.playButton.toolTip = dictionary.getLabelAndConcatenate("videorecorder.tooltip.play", [" (", dictionary.getLabel("videorecorder.disabled"), ")"]);
				
				// reset the seek slider timer
				videoControlBar.seekSlider.resetTimerLabel();
				videoControlBar.seekSlider.setMiniMaxValues(0, 0);
				videoControlBar.seekSlider.setValue(0);
				videoControlBar.seekSlider.enable(false);
				
				videoControlBar.recordButton.toolTip = dictionary.getLabel("videorecorder.tooltip.stop.recording");
				
				videoDisplayPanel.status = dictionary.getLabel("videorecorder.recording");
				
				recTimer = new Timer(250);
				recTimer.addEventListener(TimerEvent.TIMER, videoControlBar.seekSlider.updateTimerLabelForRecording);
				recTimer.start();
			}
			
			// onStopPublish callback, called from videoDisplay
			private function onStopPublish(event:VideoDisplayEvent):void{
				// no matter what, the video just recorded is now on the server
				offlinePlayback = false;
				
				if(mode == "recorderModeFCK"){											
					// alert complete
					Alert.show(dictionary.getLabel("videorecorder.recording.complete.fck"));
					
					// play the movie from the Red5 server
					if(mic && !cam) videoDisplay.makeReady(filename, "audio", false);
					else videoDisplay.makeReady(filename, "video", false);
					
					// change the panel status
					videoDisplayPanel.status = dictionary.getLabel("videorecorder.ready");
					
					// update tooltip
					videoControlBar.recordButton.toolTip = dictionary.getLabel("videorecorder.tooltip.start.recording.again");
					
					// enable saving and closing
					videoControlBar.saveAndCloseButton.enabled = true;
					videoControlBar.saveAndCloseButton.toolTip = dictionary.getLabel("videorecorder.tooltip.save.recording");
				}
				else if(mode == "recorderModeAuthor"){							
					// get the details needed
					getDetailsPopUp = GetRecordingDetailsPopUp(PopUpManager.createPopUp(this, GetRecordingDetailsPopUp, true));
					PopUpManager.centerPopUp(getDetailsPopUp);
					getDetailsPopUp.init(dictionary);
					getDetailsPopUp.addEventListener("popUpClose", popUpRemovedHandler);
				}
				
				// copy recording to lams server
				copyRecordingToLamsServer(red5RecordingsUrl + filename + ".flv", lamsEarDir + saveToLamsDestUrl, filename + ".flv");
					
				recTimer.stop();
			}
						
			// onSeekPress callback, called from seekSlider
			private function onSeekPress(event:SliderEvent):void{

			}
			
			// onSeekRelease callback, called from seekSlider
			private function onSeekRelease(event:SliderEvent):void{
				videoDisplayPanel.status = dictionary.getLabel("videorecorder.buffering");
				videoControlBar.playButton.setStyle("icon", playIcon);
				videoControlBar.playButton.enabled = false;
				videoControlBar.playButton.toolTip = dictionary.getLabelAndConcatenate("videorecorder.tooltip.play", [" (", dictionary.getLabel("videorecorder.disabled"), ")"]);
				videoControlBar.seekSlider.enable(false);
			}
			
			// onPauseSeek callback, called from seekSlider
			private function onPauseSeek(event:VideoDisplayEvent):void{

			}
			
			// onReadySeek callback, called from videoDisplay
			private function onReadySeek(event:VideoDisplayEvent):void{
				videoControlBar.playButton.enabled = true;
				videoControlBar.playButton.toolTip = dictionary.getLabel("videorecorder.tooltip.resume");
				videoControlBar.seekSlider.enable(true);
				videoDisplayPanel.status = dictionary.getLabel("videorecorder.ready");
			}
			
			// onScreenShotTaken callback, called from screenShotter in videoDisplay
			private function onScreenShotTaken(event:ScreenShotterEvent):void{
				// only save screenshot if in author mode
				if(mode == "recorderModeAuthor"){
					// get the preview image
					var previewImage:BitmapData = event.previewImage;
					
					// call the service
					savePreviewImage(lamsEarDir + saveToLamsDestUrl, filename, "jpg", previewImage);
				}
			}
		]]>
	</mx:Script>
	<mx:Panel x="10" y="10" width="340" height="310" layout="absolute" id="videoDisplayPanel">
		<ns1:VideoDisplay x="0" y="0" id="videoDisplay" />
		<ns2:VideoControlBar x="127" y="216" id="videoControlBar" mode="{mode}">
		</ns2:VideoControlBar>
	</mx:Panel>
	
</mx:Application>
