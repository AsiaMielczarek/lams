<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
</head>
<body bgcolor="white">

<p>
This content repository is designed to store single files and 
packages of files on disk in a relatively. It is not a full 
blown repository as you would find behind a web development
package. 
</p>
<p>
Each entry in the repository is represented as a "node", which 
has a unique id or uuid. Each node belongs to a workspace, and
there may be many versions to the node. The files are stored on disk
and the information about the files is stored in the lams_cr_* tables
in the database.
</p>
<p>
A node may represent a single file (a FILENODE) or be a package node. A 
package node has a set of child nodes which are file nodes. 
</p>
<UL>
<LI>To create a file node, you supply an input stream, the 
filename and mimeType (if known) to the repository. The file is stored 
and these details are all returned when the node is accessed. 
</LI>
<LI>To create
a package node, you put all the files in the package in a directory
in the file system, then supply the directory path and the name 
of the initial file in the package to the repository. When you
get the package node back, you can access the stream of the initial
file and then work from there.
</LI>
<LI>The repository also supports a data node, which is node
that has no child nodes and no file. There isn't any interface
that supports a child node but it can be added easily if desired.
</LI>
</UL>

<p>The repository keeps a set of properties for each node. At the moment,
these are read only to tools. An additional parameter
containing arbitrary nodes could easily be added to the repository
calls and this would allow the repository to store arbitrary properties
on behalf of tools.
</p>

<H2>Classes</H2>
<p>The classes of interest to tools are as follows. Apart from SimpleCredentials, tools should use the interfaces
and not the implemented classes to allow the implementation to be changed in the future.

<TABLE>
<TR><TD>ICredentials,SimpleCredentials</TD><TD>SimpleCredentials is an implementation of ICredentials. To log in, the 
tool will create a SimpleCredentials object.</TD></TR>
<TR><TD>IRepository</TD><TD>The interface used for access to the repository. This is the equivalent of a SLSB interface
to the repository. It is implemented by singleton SimpleRepository and accessed via the Spring context. </TD></TR>
<TR><TD>ITicket</TD><TD>The Ticket represents the "authorisation" key to the repository. When the tool logs in, it
will be passed a SimpleTicket object, which implements the ITicket interface. This ticket must be supplied
back to the repository to access the tool's nodes.</TD></TR>
<TR><TD>IValue</TD><TD>An object that allows the value of a property to be used as a String, Long, Double, Boolean
or Calendar. At present, only Strings have been used so other types (particularly Calendar) may not
function correctly. Implemented by CrNodeVersionProperty (a Hibernate based data object).</TD></TR>
<TR><TD>IVersionDetail</TD><TD>Describes the versions of a node. Useful for displaying a version history if the
user needs to select a particular version. Implemented by SimpleVersionDetail.</TD></TR>
<TR><TD>IVersionedNode</TD><TD>The IVersionedNode interface represents a particular version of a node. When 
the tool asks for a file or package, it will be returned the node representing the files. This node
will allow the package to get not only the filestream but the original file name and mime type.</TD></TR>
<TR><TD>NodeKey</TD><TD>The key to a node is made up of the UUID (Long) and a version (Long). This class
encapsulates both keys, and is used to return the keys when a node is created/updated.</TD></TR>
<TR><TD>NodeType</TD><TD>Defines all the valid node types. Used for testing
whether something is a file node or a package node: e.g. isNodeType(NodeType.FILENODE).</TD></TR>
<TR><TD>PropertyName</TD><TD>Defines all the current property names - such as MIMETYPE, FILENAME.
Used to get the appropriate property from a node. e.g. IValue value = node.getProperty(PropertyName.MIMETYPE).</TD></TR>
<TR><TD>PropertyType</TD><TD>Defines what type a property really is - String, Long, Double, etc.</TD></TR>
</TABLE>

<p>Note:  All interfaces with Admin in their name are only to be used within the repository and must not be used by tools. 
It is intended to make these protected interfaces if possible - they are used by Spring so this may be difficult.</p>

<h2>Typical Usage</h2>

<P>
Sample usage of the repository can be seen in example webapp, built as lamscr.war. The struts classes
are in org.lamsfoundation.lams.contentrepository.struts (in the src hierarchy)
and the jsps are in the web hierarchy.
</P>

<P>When a tool is installed, it should identify itself to the repository and create a new workspace</P>
<PRE>
	ApplicationContext context = new ClassPathXmlApplicationContext(IRepository.REPOSITORY_CONTEXT_PATH);
	IRepository	repository = (IRepository)context.getBean(IRepository.REPOSITORY_SERVICE_ID);
	ICredentials cred =  new SimpleCredentials(toolName, toolId); 
	repository.createCredential(cred);
	repository.addWorkspace(cred, workspaceName);
</PRE>

<P>Before accessing the repository, the tool will need to log in.
Once the tool has been given a ticket, it must use the same repository
object (ie a repository returned by the same context). If it gets a repository
from a different context, the ticket will not be recognised and access denied.
This is a shortcoming in the repository and needs to be fixed. 
</P>
<p>There is currently no timeout on a ticket (despite what the exception 
says) so the tool may keep it for months if it wants. But if the tool 
receives an access denied exception, then something has gone wrong and the 
ticket is no longer valid so the tool should log in again and get a new
ticket.</P>
<PRE>
	ITicket ticket = repository.login(cred, workspaceName);
</PRE>

<P>Using the ticket, the tool can now add, retrieve and delete nodes. Deleting a package
node deletes all the files in the package. Warning: deleting 
removes the node completely - from both the database and the file system.</P>
<PRE>
	NodeKey fileNodeKeyV1 = repository.login.addFileItem(ticket, inputstream, filename, 
						mimeType, versionDescription);
	IVersionedNode version1Node = repository.getFileItem(ticket,fileNodeKeyV1.getUuid(), fileNodeKeyV1.getVersion());

	NodeKey fileNodeKeyV2 = getRepository().updateFileItem(ticket, fileNodeKeyV1.getUuid(), filename,
	IVersionedNode version2Node = repository.getFileItem(ticket,fileNodeKeyV2.getUuid(), fileNodeKeyV2.getVersion());
	IVersionedNode latestFileVersionNode = repository.getFileItem(ticket,fileNodeKeyV2.getUuid(), null);
	InputStream isForOutputToScreen1 = latestFileVersionNode.getFile();

	String[] problemFiles = repository.deleteVersion(ticket,fileNodeKeyV1.getUuid(), fileNodeKeyV1.getVersion());

	NodeKey packageNodeKeyV1 = repository.addPackageItem(ticket,directoryName, initialFile, versionDescription);
	IVersionedNode package1Node = repository.getFileItem(packageNodeKeyV1.getUuid(), packageNodeKeyV1.getVersion());

	NodeKey packageNodeKeyV2 = repository.updatePackageItem(ticket, packageNodeKeyV1.getUuid(), directoryName, initialFile, versionDescription);
	IVersionedNode package2Node = repository.getFileItem(packageNodeKeyV2.getUuid(), packageNodeKeyV2.getVersion());
	IVersionedNode latestPackageVersionNode = repository.getFileItem(ticket,fileNodeKeyV2.getUuid(), null);
	InputStream isForOutputToScreen2 = latestPackageVersionNode();

	String[] problemFiles2 = getRepository().deleteNode(ticket,packageNodeKeyV1.getUuid());
</PRE>

<p>When the tool is complete, it should logout from the repository. This
invalidates the ticket.</p>
<PRE>
	repository.logout(ticket);
</PRE>
<H2>Exceptions and Transactions</H2>

<P>There are two sorts of exceptions - RepositoryCheckedException and
RepositoryRuntimeException.</P>

<P>RepositoryRuntimeException may be thrown
by any call to the repository irrespective of whether it is defined
in the signature. It is used for internal errors, not errors caused
by bad input from a tool. The repository may also thrown other runtime
errors, such as the Spring runtime errors which wrap Hibernate errors.
</P>

<P>RepositoryCheckedException is the superclass to 10 detailed
checked exceptions. Most calls throw more than one detailed exception.
Calling code can catch either the detailed exceptions or just 
RepositoryCheckedException.</P>

<p>All the calls on IRepository should be transactional, defined
in the Spring context file. If any are not defined in the context file, then
this is a bug and should be corrected!!!!!!!!!. All 
of the transactions should roll back on both the RepositoryCheckedException
(as it is defined in the context file) and RepositoryRuntimeException
as the Spring trasactions will roll back on any RuntimeException.
However, all we can roll back are database changes. We cannot roll back
file system changes. For this reason, we try to do the database changes
first. But it isn't perfect. </p>

<h2>Configuration</h2>

<UL>
<LI><STRONG>Repository location</STRONG> Edit 
org.lamsfoundation.lams.contentrepository.contentRepositoryApplicationContext.xml 
(in the src hierarchy). Defaults to D:\repository. This can reside anywhere it 
can be accessed as a directory - it does not need to be under the JBOSS hierarchy.
</LI>
<LI><STRONG>Database connection</STRONG> Edit 
org.lamsfoundation.lams.contentrepository.contentRepositoryApplicationContext.xml 
(in the src hierarchy). Defaults to jdbc:mysql://localhost/lams.
</LI>
<LI><STRONG>Database user and password</STRONG> Edit properties.xml (in the root of the project)
to set the JBOSS directory. This is required for the database related ANT tasks.
</LI>
<LI><STRONG>JBOSS location</STRONG> Edit properties.xml (in the root of the project)
to set the JBOSS directory. This is required for the deploy and copyfiles ANT tasks.
</LI>
<LI><STRONG>JUNIT Testing</STRONG> Edit the TEXT_FILEPATH, TEXT_FILENAME, BINARY_FILEPATH
BINARY_FILENAME, PACKAGE_DIR_PATH, PACKAGE_TEST_FILE in 
org.lamsfoundation.lams.contentrepository.BaseTestCase ( in the test hierarchy).
These must point to files on your PC. The TEXT* variables should point to a text file,
the BINARY* to a binary file (e.g. jpeg, zip file). The allows you to check that <EM>manually</EM>
that neither text nor binary files are corrupted. The PACKAGE_DIR_PATH should be 
a directory containing an index.html file and a series of other files (e.g. images
to go with the index.html file). The PACKAGE_TEST_FILE should be the relative 
path to a file within the directory.
</LI>
</UL>

<h2>Building the Repository</h2>
<p>After configuring (see previous section) use the ANT Build script to build and deploy
the content repository code.
<UL>
<LI>
With the database running, run the <STRONG>create-db-tables</STRONG> then the 
<STRONG>insert-test-data</STRONG> targets.<BR>
The create-db-tables and insert-test-data targets can be run at any time. If you 
run the create-db-tables then you will need to clear out all the directories in the 
repository otherwise it fail when it uses an id that has a file in the repository.
You must run insert-test-data  before running the JUNIT tests or the
create workspace and create user tests will fail (as the test values to be added
will already exist). 
</LI>
<LI>
At this point, you can run the JUNIT tests if desired. To run them, run the 
org.lamsfoundation.lams.contentrepositoryAllTests junit test suite. This will
run all the current tests. Note: the NodeTransactionTest class is not
complete so it is not included in the test suite.
</LI>
<LI>
The first time you compile, you will need to run the <STRONG>copyfiles</STRONG> target. 
This is required to copy all the jar files from the project to JBOSS. You may have 
all the files in your JBOSS already - many of them overlap with common. 
One jar that you are likely to be missing it the commons upload. 
This is not required for the repository per se, but is required for the example web app.
</LI>
<LI>
Finally, run the <STRONG>deploy-lamscr-jar</STRONG> or <STRONG>deploy-lamscr-jarwar</STRONG> target
(and not both). Both targets will compile and deploy the jar file, while
the second one will also deploy the example usage war file. The jar file 
is the repository code. The war file is the example web app. The war file is 
<EM>not</EM> needed for the repository to function. If you just want to 
deploy the jar file, run <STRONG>lamscr-jar</STRONG> target and copy the 
jar file manually. When development is complete, the build file will be 
changed to deploy these files separately.
</LI>
</UL>

</body>
</html>