<?xml version="1.0" encoding="utf-8"?>
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" layout="absolute" xmlns:ns1="org.lamsfoundation.lams.common.ui.components.*" backgroundGradientAlphas="[1.0, 1.0]" backgroundGradientColors="[#FFFFFF, #FFFFFF]" width="361" height="331" preinitialize="onPreinitialize(event)" applicationComplete="onApplicationComplete(event)" xmlns:ns2="*">

	<mx:Script>
		<![CDATA[
			
			//includes
			include "HTTPServices.as"
			
			// imports
			import mx.managers.PopUpManager;
			import org.lamsfoundation.lams.common.util.VideoDisplayUtil;
			import mx.containers.ControlBar;
			import mx.effects.easing.Elastic;
			import mx.effects.AddChildAction;
			import mx.states.AddChild;
			import mx.controls.TabBar;
			import org.lamsfoundation.lams.common.ui.components.VideoDisplayEvent;
			import mx.events.SliderEvent;
			import mx.controls.Button;
			import mx.controls.Alert;
			import org.lamsfoundation.lams.common.dictionary.XMLDictionary;
			import flash.external.*;
			import org.lamsfoundation.lams.common.util.LAMSStringUtil;
			import mx.containers.TitleWindow;
			
			// flashvars
			[Bindable] private var mode:String;
			private var red5ServerUrl:String;
			private var red5RecordingsUrl:String;
			private var saveToLamsDestUrl:String;
			private var contentFolderUrl:String;
			private var lamsEarDir:String;
			private var serverUrl:String;
			private var filename:String;
			private var toolContentId:int;
			private var userId:int;
			private var languageXML:XML;
			private var toolServletUrl:String;
			private var saveToLamsServletUrl:String;
			
			// needed stuff
			private var dictionary:XMLDictionary;
			private var nc:NetConnection;
			private var playTimer:Timer;
			private var recTimer:Timer;
			private var cam:Camera;
			private var mic:Microphone;
			private var languageTimer:Timer;
			private var getDetailsPopUp:GetRecordingDetailsPopUp;
			
			// static strings
			private static var red5App:String = "oflaDemo";
			private static var toolServletLocation:String = "tool/lavidr10/videoRecorderActions.do";
			private static var saveToLamsServletLocation:String = "GetRecording";
			
			// icon embeds
			[Embed(source="../../../../../../lams_central/web/images/icons/control_play.png")] [Bindable] private var playIcon:Class;
			[Embed(source="../../../../../../lams_central/web/images/icons/control_pause.png")] [Bindable] private var pauseIcon:Class;
			[Embed(source="../../../../../../lams_central/web/images/icons/control_record.png")] [Bindable] private var recordIcon:Class;
			[Embed(source="../../../../../../lams_central/web/images/icons/accept.png")] [Bindable] private var saveIcon:Class;
			
			// called first of all, before any components are initialized
			private function onPreinitialize(event:Event):void{
				// get flashvars
				getFlashVars();
				
				// for testing purposes (when running in debug)
				if(mode == null){
					red5ServerUrl = new String("rtmp://172.20.100.22/");
					serverUrl = new String("http://172.20.100.220:8080/lams/");
					mode = new String("recorderModeAuthor");
					toolContentId = 24;
				}
			}
			
			// add the appropriate controlbar, called after the videoDisplay component is added to the panel container
			private function addControlBar(event:Event):void{
				// create the video control bar
				videoControlBar = new VideoControlBar();
				
				// give it the mode so it can delete buttons once created
				videoControlBar.mode = mode;
				
				// add the control bar now, before the panel is added, so the control bar is anchored
				videoDisplayPanel.addChild(videoControlBar);
			}
			
			// called after everything is created and ready to go
			private function onApplicationComplete(event:Event):void {
				// add an external interface callback to all setLanguageXML to be called from js
				ExternalInterface.addCallback("setLanguageXML", setLanguageXML);					
				
				// init labels if languageXML is not empty
				if(languageXML.toString() != ""){
					setLanguageXML(languageXML);
				}
				else{
					// create a placeholder dictionary
					dictionary = new XMLDictionary(new XML(""));
					
					// attempt to get the dictionary via servlet
					getLanguageXMLFromServer();
				}
				
				// set button icons
				setIcons();
				
				// init buttons states
				videoControlBar.playButton.enabled = false;
				videoControlBar.seekSlider.enable(false);
				videoControlBar.saveAndCloseButton.enabled = false;
				
				// add listeners
				addListeners();
				
				// add the app name to the red5 url to complete the url
				red5ServerUrl += red5App;
				
				// add the tool servlet location
				toolServletUrl = serverUrl + toolServletLocation;
				
				// add the save to lams servlet location
				saveToLamsServletUrl = serverUrl + saveToLamsServletLocation;
				
				/*
				Alert.show(
					"filename: " + filename +
					"\nred5ServerUrl: " + red5ServerUrl +
					"\nserverUrl: " + serverUrl +
					"\nlanguageXML: " + languageXML +
					"\ntoolContentId: " + toolContentId +
					"\ntoolServletUrl: " + toolServletUrl +
					"\nsaveToLamsServletUrl: " + saveToLamsServletUrl +
					"\nred5RecordingsUrl: " + red5RecordingsUrl +
					"\nsaveToLamsDestUrl: " + saveToLamsDestUrl +
					"\nlamsEarDir: " + lamsEarDir +
					"\nmode: " + mode);
				*/
				
				// swtich on mode
				switch(mode){
					case "playerModeOnline":{
						createConnection();
						break;
					}

					case "playerModeOffline":{
						var nc:NetConnection = new NetConnection();
						nc.connect(null);
						videoDisplay.setNetConnection(nc);
						videoDisplay.makeReadyVideo(filename);
						break;
					}
					case "recorderModeFCK":{
						toolContentId = -1;
						
						if(!isWebcamInfoSet())
						{
							Security.showSettings();
							setWebcamInfo(true);
						}
						
						cam = VideoDisplayUtil.setupCamera();
						mic = VideoDisplayUtil.setupMic();
						videoDisplay.attachCamera(cam);
						videoDisplay.attachMic(mic);
						createConnection();
						break;
					}
					case "recorderModeAuthor":{
						userId = -1;
						
						if(!isWebcamInfoSet())
						{
							Security.showSettings();
							setWebcamInfo(true);
						}
						
						cam = VideoDisplayUtil.setupCamera();
						mic = VideoDisplayUtil.setupMic();
						videoDisplay.attachCamera(cam);
						videoDisplay.attachMic(mic);
						createConnection();

						break;
					}
				}
			}
						
			// sets language xml, usually called at a later time through javascript
			public function setLanguageXML(languageXMLString:String):void{
				if(languageXMLString != "" || languageXMLString != null){
					try{
						languageXML = XML(languageXMLString);
					}
					catch(e:Error){
						languageXML = XML(unescape(languageXMLString));
					}
					
					dictionary = new XMLDictionary(languageXML);
					setLabels();
					setTooltips();
				}
			}
			
			// adds some listeners
			private function addListeners():void{
				videoDisplay.addEventListener(VideoDisplayEvent.METADATA, onMetaData);
				videoDisplay.addEventListener(VideoDisplayEvent.PAUSE, onPause);
				videoDisplay.addEventListener(VideoDisplayEvent.UNPAUSE, onUnpause);
				videoDisplay.addEventListener(VideoDisplayEvent.READY, onReady);
				videoDisplay.addEventListener(VideoDisplayEvent.COMPLETE, onComplete);
				videoDisplay.addEventListener(VideoDisplayEvent.STARTPUBLISH, onStartPublish);
				videoDisplay.addEventListener(VideoDisplayEvent.STOPPUBLISH, onStopPublish);
				videoDisplay.addEventListener(VideoDisplayEvent.PAUSESEEK, onPauseSeek);
				videoDisplay.addEventListener(VideoDisplayEvent.READYSEEK, onReadySeek);	
				
				videoControlBar.playButton.addEventListener(MouseEvent.CLICK, playClick);
				
				videoControlBar.seekSlider.addEventListener(SliderEvent.THUMB_PRESS, onSeekPress);
				videoControlBar.seekSlider.addEventListener(SliderEvent.THUMB_RELEASE, onSeekRelease);
				
				switch(mode){
					case "recorderModeFCK":{
						videoControlBar.recordButton.addEventListener(MouseEvent.CLICK, recordClick);
						videoControlBar.saveAndCloseButton.addEventListener(MouseEvent.CLICK, saveAndCloseClick);
						break;
					}
					case "recorderModeAuthor":{
						videoControlBar.recordButton.addEventListener(MouseEvent.CLICK, recordClick);
						break;
					}
				}
			}
			
			// sets initial labels
			private function setLabels():void{
				if(mode == "playerModeOnline" || mode == "playerModeOffline"){
					videoDisplayPanel.title = dictionary.getLabel("videorecorder.video.player");
				}
				else if(mode == "recorderModeFCK"){
					videoDisplayPanel.title = dictionary.getLabel("videorecorder.video.recorder");
				}
				
				videoDisplayPanel.status = dictionary.getLabel("videorecorder.waiting");
			}
			
			// sets initial tooltips
			private function setTooltips():void{
				switch(mode){
					case "playerModeOnline":{
						videoControlBar.playButton.toolTip = dictionary.getLabel("videorecorder.tooltip.play");
						break;
					}
					case "playerModeOffline":{
						videoControlBar.playButton.toolTip = dictionary.getLabel("videorecorder.tooltip.play");
						break;
					}
					case "recorderModeFCK":{
						videoControlBar.playButton.toolTip = dictionary.getLabelAndConcatenate("videorecorder.tooltip.play", [" (", dictionary.getLabel("videorecorder.disabled"), ")"]);
						videoControlBar.recordButton.toolTip = dictionary.getLabel("videorecorder.tooltip.start.recording");
						videoControlBar.saveAndCloseButton.toolTip = dictionary.getLabelAndConcatenate("videorecorder.tooltip.save.recording", [" (", dictionary.getLabel("videorecorder.disabled"), ")"]);
						break;
					}
					case "recorderModeAuthor":{
						videoControlBar.playButton.toolTip = dictionary.getLabelAndConcatenate("videorecorder.tooltip.play", [" (", dictionary.getLabel("videorecorder.disabled"), ")"]);
						videoControlBar.recordButton.toolTip = dictionary.getLabel("videorecorder.tooltip.start.recording");
						break;
					}
				}
			}
			
			// sets initial icons
			private function setIcons():void{
				videoControlBar.playButton.setStyle("icon", playIcon);
				videoControlBar.recordButton.setStyle("icon", recordIcon);
				videoControlBar.saveAndCloseButton.setStyle("icon", saveIcon);
			}
			
			// gets flashvars
			private function getFlashVars():void{
				red5ServerUrl = Application.application.parameters.red5ServerUrl;
				serverUrl = Application.application.parameters.serverUrl;
				filename = Application.application.parameters.filename;
				languageXML = XML(Application.application.parameters.languageXML);
				mode = Application.application.parameters.mode;
				toolContentId = Application.application.parameters.toolContentId;
				userId = Application.application.parameters.userId;
				red5RecordingsUrl = Application.application.parameters.red5RecordingsUrl;
				saveToLamsDestUrl = Application.application.parameters.saveToLamsDestUrl;
				lamsEarDir = Application.application.parameters.lamsEarDir;
				contentFolderUrl = Application.application.parameters.contentFolderUrl;
			}
			
			// checks for previous webcam info
			private function isWebcamInfoSet():Boolean{
				var lamsVideoRecorderInfo:Object = SharedObject.getLocal("lamsWebcamInfo");
				
				if(lamsVideoRecorderInfo.data.webcamSet){
					return lamsVideoRecorderInfo.data.webcamSet;
				}else{
					return false;
				}
					
			}
			
			// sets webcam info
			private function setWebcamInfo(checked:Boolean):void{
				var lamsVideoRecorderInfo:Object = SharedObject.getLocal("lamsWebcamInfo");
				lamsVideoRecorderInfo.data.webcamSet = checked;
			}
			
			// creates a netconnection if it is needed
			private function createConnection():void{
				// create basic netConnection object
				nc = new NetConnection();
			
				// add some listeners to it
				nc.addEventListener(NetStatusEvent.NET_STATUS, ncStatusHandler);
				nc.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
				nc.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);
				
				// set the nc to the videodisplay
				videoDisplay.setNetConnection(nc);
				
				// connect to the local Red5 server and wait for callback
				nc.connect(red5ServerUrl);
				
				// wait for NetStatusEvent to be thrown
			}
			
			// callback called on NetConnection connect event
			private function ncStatusHandler(event:NetStatusEvent):void {
				// get the info object
				var infoObject:Object = event.info;
	  
				// if successful connection
				if (infoObject.code == "NetConnection.Connect.Success") {
					// enable application
					Application.application.enabled = true;
					
					// if we are in a player instance
					if(mode == "playerModeOffline" || mode == "playerModeOnline"){
						videoDisplay.makeReadyVideo(filename);
					}
					// if we are in fck mode or if we are in recorder mode AND have no input filename
					else if(mode == "recorderModeFCK" || (mode == "recorderModeAuthor" && filename == "")){
						videoDisplay.startViewCamera();
					}
					// if we are in author mode and are given a filename, don't start camera, play recording instead
					else if(mode == "recorderModeAuthor" && filename != ""){					
						// change the start recording button's label
						videoDisplay.makeReadyVideo(filename);
						
						// update tooltip
						videoControlBar.recordButton.toolTip = dictionary.getLabel("videorecorder.tooltip.start.recording.again");
					}

				}
				// if connection unsuccessful
				else if(infoObject.code == "NetConnection.Connect.InvalidApp"){
					Application.application.enabled = false;			
					// pop an alert
					Alert.show("Web appplication not available");
				}
				else if(infoObject.code == "NetConnection.Connect.Failed"){
					Application.application.enabled = false;				
					// pop an alert
					Alert.show("NetConnection not connected");
				}
				else if(infoObject.code == "NetConnection.Connect.Closed"){
					Application.application.enabled = false;
					// pop an alert
					Alert.show("NetConnection closed");
				}
			}
			
			// netconnection security error handler
			private function securityErrorHandler(event:SecurityErrorEvent):void {
				trace("securityErrorHandler: " + event);
			}
			
			// netconnection async error handler
			private  function asyncErrorHandler(event:AsyncErrorEvent):void {
				trace("securityErrorHandler: " + event);
			} 
	    	
        	// bw detection handler
			public function onBWDone(infoObject:Object):void {
				// print its properties
    			trace(VideoDisplayUtil.printInfoObject(infoObject, "onBWDone"));
			}
			
			// play button click handler
			private function playClick(event:MouseEvent):void{
				videoDisplay.play();
			}

        	// handler called when the confirm action ("ok", "cancel", "save") on a popup is hit
        	private function popUpRemovedHandler(event:Event):void{
        		// if the given popup is of type getDetailsPopUp
        		if(event.target == getDetailsPopUp){
        			// get the details
        			var title:String = getDetailsPopUp.titleInput.text;
        			var description:String = getDetailsPopUp.descriptionInput.text;
        			
        			// call the http service to save a recording
        			saveRecordingToServer(title, description, filename + ".flv", toolContentId);
        		}
        		
        		if(event.target is TitleWindow){
        			PopUpManager.removePopUp(TitleWindow(event.target));
        		}
        	}
        	
			// record button click handler
			private function recordClick(event:MouseEvent):void{
				if(!videoDisplay.isPublishing){
					if(mode == "recorderModeFCK")
						filename = VideoDisplayUtil.createFilenameForFCK(userId);
					else if(mode == "recorderModeAuthor")
						filename = VideoDisplayUtil.createFilenameForAuthor(toolContentId);
						
					videoDisplay.startPublish(filename);
				}
				else if(videoDisplay.isPublishing)
					videoDisplay.stopPublish();
			}
			
			// save and close button click handler
			private function saveAndCloseClick(event:MouseEvent):void{
				var eventObj:Object = new Object();
			 	eventObj.filename = contentFolderUrl + filename + ".flv";
				eventObj.red5ServerUrl = red5ServerUrl;
				eventObj.mode = "playerModeOffline";
				eventObj.languageXML = languageXML.toXMLString();

				ExternalInterface.call("saveToFCKEditor", eventObj); 
			}
			
			// onMetaData callback, called from videoDisplay
			private function onMetaData(event:VideoDisplayEvent):void{
				videoDisplayPanel.status = dictionary.getLabel("videorecorder.buffering");
				videoControlBar.seekSlider.setMiniMaxValues(0, event.metadata.duration);
				videoControlBar.seekSlider.setValue(0);
				videoControlBar.seekSlider.startTimerLabel();
			}
			
			// onReady callback, called from videoDisplay
			private function onReady(event:VideoDisplayEvent):void{
				videoControlBar.playButton.enabled = true;
				videoControlBar.seekSlider.enable(true);
				videoControlBar.playButton.setStyle("icon", playIcon);
				videoControlBar.playButton.toolTip = dictionary.getLabel("videorecorder.tooltip.play");
				videoDisplayPanel.status = dictionary.getLabel("videorecorder.ready");
			}
			
			// onUnpause callback, called from videoDisplay
			private function onUnpause(event:VideoDisplayEvent):void{
				videoControlBar.playButton.setStyle("icon", pauseIcon);
				videoControlBar.playButton.toolTip = dictionary.getLabel("videorecorder.tooltip.pause");
				videoDisplayPanel.status = dictionary.getLabel("videorecorder.playing");
			}
			
			// onPause callback, called from videoDisplay
			private function onPause(event:VideoDisplayEvent):void{
				videoControlBar.playButton.setStyle("icon", playIcon);
				videoControlBar.playButton.toolTip = dictionary.getLabel("videorecorder.tooltip.resume");
				videoDisplayPanel.status = dictionary.getLabel("videorecorder.paused");
			}
			
			// onComplete callback, called from videoDisplay
			private function onComplete(event:VideoDisplayEvent):void{
				videoControlBar.playButton.setStyle("icon", playIcon);
				videoControlBar.playButton.toolTip = dictionary.getLabel("videorecorder.tooltip.play");
				videoDisplayPanel.status = dictionary.getLabel("videorecorder.ready");
			}
			
			// onStartPublish callback, called from videoDisplay
			private function onStartPublish(event:VideoDisplayEvent):void{
				// stop the timer if it is created
				if(playTimer)
					playTimer.stop();
					
				videoControlBar.playButton.enabled = false;
				videoControlBar.playButton.toolTip = dictionary.getLabelAndConcatenate("videorecorder.tooltip.play", [" (", dictionary.getLabel("videorecorder.disabled"), ")"]);
				
				// reset the seek slider timer
				videoControlBar.seekSlider.resetTimerLabel();
				videoControlBar.seekSlider.setMiniMaxValues(0, 0);
				videoControlBar.seekSlider.setValue(0);
				videoControlBar.seekSlider.enable(false);
				
				videoControlBar.recordButton.toolTip = dictionary.getLabel("videorecorder.tooltip.stop.recording");
				
				videoDisplayPanel.status = dictionary.getLabel("videorecorder.recording");
				
				recTimer = new Timer(250);
				recTimer.addEventListener(TimerEvent.TIMER, videoControlBar.seekSlider.updateTimerLabelForRecording);
				recTimer.start();
			}
			
			// onStopPublish callback, called from videoDisplay
			private function onStopPublish(event:VideoDisplayEvent):void{
				if(mode == "recorderModeFCK"){
					// alert complete
					Alert.show(dictionary.getLabel("videorecorder.recording.complete.fck"));
					
					// change the start recording button's label
					videoDisplay.makeReadyVideo(filename);
					
					// change the panel status
					videoDisplayPanel.status = dictionary.getLabel("videorecorder.ready");
					
					// update tooltip
					videoControlBar.recordButton.toolTip = dictionary.getLabel("videorecorder.tooltip.start.recording.again");
					
					// enable saving and closing
					videoControlBar.saveAndCloseButton.enabled = true;
					videoControlBar.saveAndCloseButton.toolTip = dictionary.getLabel("videorecorder.tooltip.save.recording");
					
					// copy recording to lams server
					copyRecordingToLamsServer(red5RecordingsUrl + filename + ".flv", lamsEarDir + saveToLamsDestUrl, filename + ".flv");
				}
				else if(mode == "recorderModeAuthor"){
					// get the details needed
					getDetailsPopUp = GetRecordingDetailsPopUp(PopUpManager.createPopUp(this, GetRecordingDetailsPopUp, true));
					PopUpManager.centerPopUp(getDetailsPopUp);
					getDetailsPopUp.init(dictionary);
					getDetailsPopUp.addEventListener("popUpClose", popUpRemovedHandler);
				}
				
				recTimer.stop();
			}
						
			// onSeekPress callback, called from seekSlider
			private function onSeekPress(event:SliderEvent):void{

			}
			
			// onSeekRelease callback, called from seekSlider
			private function onSeekRelease(event:SliderEvent):void{
				videoDisplayPanel.status = dictionary.getLabel("videorecorder.buffering");
				videoControlBar.playButton.setStyle("icon", playIcon);
				videoControlBar.playButton.enabled = false;
				videoControlBar.playButton.toolTip = dictionary.getLabelAndConcatenate("videorecorder.tooltip.play", [" (", dictionary.getLabel("videorecorder.disabled"), ")"]);
				videoControlBar.seekSlider.enable(false);
			}
			
			// onPauseSeek callback, called from seekSlider
			private function onPauseSeek(event:VideoDisplayEvent):void{

			}
			
			// onReadySeek callback, called from videoDisplay
			private function onReadySeek(event:VideoDisplayEvent):void{
				videoControlBar.playButton.enabled = true;
				videoControlBar.playButton.toolTip = dictionary.getLabel("videorecorder.tooltip.resume");
				videoControlBar.seekSlider.enable(true);
				videoDisplayPanel.status = dictionary.getLabel("videorecorder.ready");
			}
	
		]]>
	</mx:Script>
	<mx:Panel x="10" y="10" width="340" height="310" layout="absolute" id="videoDisplayPanel">
		<ns1:VideoDisplay x="0" y="0" id="videoDisplay" />
		<ns2:VideoControlBar x="127" y="216" id="videoControlBar" mode="{mode}">
		</ns2:VideoControlBar>
	</mx:Panel>
	
</mx:Application>
